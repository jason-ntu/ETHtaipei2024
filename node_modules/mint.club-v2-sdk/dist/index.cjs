'use strict';

var chains = require('viem/chains');
var viem = require('viem');
var accounts = require('viem/accounts');
var MerkleTree = require('merkletreejs');
var crypto = require('crypto');
var lodash = require('lodash');
var client = require('@filebase/client');

function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}

var chains__namespace = /*#__PURE__*/_interopNamespaceDefault(chains);

const DOCUMENTATION_URL = "https://sdk.mint.club";

function commify(x) {
  const parts = x.toString().split(".");
  parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ",");
  return parts.join(".");
}
function uncommify(str) {
  return str.toString().replace(/,/g, "");
}
function handleScientificNotation(num) {
  const str = num?.toString();
  if (str?.includes("e")) {
    const [coefficient, exponent] = str.split("e");
    const decimalCount = countDecimals(Number(coefficient));
    const exponentValue = parseInt(exponent, 10);
    if (exponentValue >= 0) {
      const result = Number(num).toLocaleString();
      return result;
    } else {
      const result = Number(num).toFixed(Math.abs(exponentValue) + decimalCount);
      return result;
    }
  }
  return str;
}
function countLeadingZeros(num) {
  const stringValue = handleScientificNotation(num?.toString());
  if (!stringValue || !stringValue?.includes("."))
    return 0;
  const [, decimalPart] = stringValue.split(".");
  const leadingZeros = decimalPart ? decimalPart.match(/^0*/)?.[0]?.length : 0;
  return leadingZeros;
}
function getValueAfterLeadingZeros(num) {
  const numStr = handleScientificNotation(num?.toString());
  if (!numStr)
    return;
  const matches = /\.0*([1-9]\d*)$/.exec(numStr);
  if (matches && matches[1]) {
    return parseInt(matches[1], 10);
  }
  return num;
}
function countDecimals(value) {
  const numStr = handleScientificNotation(value?.toString());
  const length = numStr?.split(".")?.[1]?.length;
  return length ?? 0;
}
function toFixed(value, t) {
  return Number(Number(value).toFixed(t));
}
function wei$1(num, decimals = 18) {
  const stringified = handleScientificNotation(num.toString());
  return viem.parseUnits(stringified, decimals);
}
function toNumber(num, decimals) {
  return Number(viem.formatUnits(num, decimals));
}
function shortenNumber(num, prefix = "") {
  num = Number(num.toString().replaceAll(",", ""));
  if (num >= 1e12) {
    return `${prefix}${toFixed(num / 1e12, 2)}T`;
  } else if (num >= 1e9) {
    return `${prefix}${toFixed(num / 1e9, 2)}B`;
  } else if (num >= 1e6) {
    return `${prefix}${toFixed(num / 1e6, 2)}M`;
  } else if (num >= 1e3) {
    return `${prefix}${toFixed(num / 1e3, 2)}K`;
  } else if (num === 0) {
    return `${prefix}0`;
  } else if (num <= 1e-6) {
    return `< ${prefix}0.000001`;
  }
  return prefix + num.toLocaleString("en-US", {
    maximumFractionDigits: 6
  });
}
function applyDecimals(num) {
  const toNum = Number(num);
  let decimalPlaces;
  if (toNum >= 1e5) {
    decimalPlaces = 0;
  } else if (toNum >= 1e3) {
    decimalPlaces = 2;
  } else if (toNum >= 10) {
    decimalPlaces = 3;
  } else if (toNum >= 1) {
    decimalPlaces = 4;
  } else if (toNum >= 0.1) {
    decimalPlaces = 5;
  } else if (toNum >= 0.01) {
    decimalPlaces = 6;
  }
  if (decimalPlaces === void 0) {
    return handleScientificNotation(toNum.toString());
  }
  return handleScientificNotation(
    toNum.toLocaleString("en-US", {
      maximumFractionDigits: decimalPlaces
    })
  );
}
function precisionRound(number, precision) {
  const factor = Math.pow(10, precision);
  return Math.round(number * factor) / factor;
}

var name = "mint.club-v2-sdk";
var files = [
	"./dist/**/*",
	"./src/**/*"
];
var type = "module";
var license = "BSD-3-Clause";
var version = "0.0.82";
var main = "./dist/index.cjs";
var module$1 = "./dist/index.mjs";
var types = "./dist/index.d.ts";
var browser = {
	"./dist/index.mjs": "./dist/index.mjs",
	"./dist/index.cjs": "./dist/index.cjs"
};
var exports$1 = {
	".": {
		node: {
			"import": "./dist/node.mjs",
			require: "./dist/node.cjs"
		},
		"import": "./dist/index.mjs",
		require: "./dist/index.cjs",
		"default": "./dist/index.mjs",
		types: "./dist/index.d.ts"
	}
};
var scripts = {
	"docs:deploy": "",
	build: "npm run purge && npx pkgroll",
	prepublishOnly: "git push && npm run build",
	purge: "npx rimraf ./dist",
	test: "npx bun test",
	"test:watch": "npx bun test --watch",
	hardhat: "NODE_ENV=hardhat npx bun test hardhat"
};
var devDependencies = {
	"@nomicfoundation/hardhat-toolbox": "^4.0.0",
	"@nomicfoundation/hardhat-viem": "^2.0.0",
	"@openzeppelin/contracts": "^5.0.2",
	"@rollup/plugin-alias": "^5.1.0",
	"@rollup/plugin-dynamic-import-vars": "^2.1.2",
	"@rollup/plugin-terser": "^0.4.4",
	"@rollup/plugin-typescript": "^11.1.6",
	"@types/bun": "^1.0.8",
	"@typescript-eslint/eslint-plugin": "^7.1.0",
	"@typescript-eslint/parser": "^7.1.0",
	bun: "^1.0.25",
	eslint: "^8.57.0",
	"eslint-config-prettier": "^9.1.0",
	hardhat: "^2.20.1",
	"mint-club-v2": "github:Steemhunt/mint.club-v2-contract",
	pkgroll: "^2.0.1",
	prettier: "^3.2.5",
	rimraf: "^5.0.5",
	"ts-node": "^10.9.2",
	typescript: "5.4.2"
};
var dependencies = {
	"@filebase/client": "^0.0.5",
	"@rollup/plugin-node-resolve": "^15.2.3",
	"@types/jsdom": "^21.1.6",
	"@types/lodash": "^4.14.202",
	abitype: "^1.0.0",
	"aws-sdk": "^2.1578.0",
	jsdom: "^24.0.0",
	"ky-universal": "^0.12.0",
	lodash: "^4.17.21",
	merkletreejs: "^0.3.11",
	viem: "2.8.5"
};
var pkg = {
	name: name,
	files: files,
	type: type,
	license: license,
	version: version,
	main: main,
	module: module$1,
	types: types,
	browser: browser,
	exports: exports$1,
	scripts: scripts,
	devDependencies: devDependencies,
	dependencies: dependencies
};

function wei(num, decimals = 18) {
  const stringified = handleScientificNotation(num.toString());
  return viem.parseUnits(stringified, decimals);
}
function getVersion() {
  return pkg.version;
}

class BaseError extends Error {
  details;
  docsPath;
  metaMessages;
  shortMessage;
  name = "MintClubSDKError";
  version = getVersion();
  constructor(shortMessage, args = {}) {
    super();
    const details = args.cause instanceof BaseError ? args.cause.details : args.cause?.message ? args.cause.message : args.details;
    const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...args.metaMessages ? [...args.metaMessages, ""] : [],
      ...docsPath ? [`Docs: ${DOCUMENTATION_URL}/${docsPath}${args.docsSlug ? `#${args.docsSlug}` : ""}`] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (args.cause)
      this.cause = args.cause;
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = args.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn) {
    return walk(this, fn);
  }
}
function walk(err, fn) {
  if (fn?.(err))
    return err;
  if (err && typeof err === "object" && "cause" in err)
    return walk(err.cause, fn);
  return fn ? null : err;
}

class TokenAlreadyExistsError extends BaseError {
  constructor() {
    super("Token already exists", {
      docsPath: "docs/sdk/network/token"
    });
  }
}
class ChainNotSupportedError extends BaseError {
  constructor(chain) {
    super(`Chain ${chain} is not supported`);
  }
}
class SymbolNotDefinedError extends BaseError {
  constructor() {
    super("You must pass in a symbol, not an address to call the `create` function", {
      docsPath: "docs/sdk/network/token/create"
    });
  }
}
class InvalidImageProvidedError extends BaseError {
  constructor() {
    super(
      "You must provide a valid url for the media. It should be either a http/https url, or a CIDv0 or CIDv1 ipfs hash that starts with `ipfs://...`",
      {
        docsPath: "docs/sdk/network/nft/create"
      }
    );
  }
}
class FilebaseKeyNeededErrror extends BaseError {
  constructor() {
    super("You must provide a filebaseApiKey to upload Files to the IPFS", {
      docsPath: "docs/sdk/network/nft/create"
    });
  }
}
class NoEthereumProviderError extends BaseError {
  constructor() {
    super("window.ethereum not found", {
      docsPath: "docs/sdk/network/transactions"
    });
  }
}
class WalletNotConnectedError extends BaseError {
  constructor() {
    super("Wallet not connected", {
      docsPath: "docs/sdk/network/transactions"
    });
  }
}
class InvalidClientError extends BaseError {
  constructor() {
    super("Client with no chain was passed", {
      docsPath: "docs/sdk/network/transactions/withPublicClient"
    });
  }
}
class CreationError extends BaseError {
  constructor(message, extra) {
    super(message, {
      docsPath: "/docs/sdk/network/token/create",
      ...extra
    });
  }
}
class AirdropContainsInvalidWalletError extends BaseError {
  constructor() {
    super("Airdrop contains invalid wallet", {
      docsPath: "docs/sdk/network/token/createAirdrop"
    });
  }
}

const BOND_ABI = [
  {
    inputs: [
      { internalType: "address", name: "tokenImplementation", type: "address" },
      {
        internalType: "address",
        name: "multiTokenImplementation",
        type: "address"
      },
      {
        internalType: "address",
        name: "protocolBeneficiary_",
        type: "address"
      },
      { internalType: "uint256", name: "creationFee_", type: "uint256" },
      { internalType: "uint256", name: "maxSteps", type: "uint256" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  { inputs: [], name: "ERC1167FailedCreateClone", type: "error" },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "MCV2_BOND__InvalidPaginationParameters", type: "error" },
  {
    inputs: [],
    name: "MCV2_Bond__CreationFeeTransactionFailed",
    type: "error"
  },
  { inputs: [], name: "MCV2_Bond__ExceedMaxSupply", type: "error" },
  { inputs: [], name: "MCV2_Bond__ExceedTotalSupply", type: "error" },
  {
    inputs: [{ internalType: "string", name: "reason", type: "string" }],
    name: "MCV2_Bond__InvalidConstructorParams",
    type: "error"
  },
  { inputs: [], name: "MCV2_Bond__InvalidCreationFee", type: "error" },
  { inputs: [], name: "MCV2_Bond__InvalidCreatorAddress", type: "error" },
  { inputs: [], name: "MCV2_Bond__InvalidCurrentSupply", type: "error" },
  { inputs: [], name: "MCV2_Bond__InvalidReceiver", type: "error" },
  {
    inputs: [{ internalType: "string", name: "reason", type: "string" }],
    name: "MCV2_Bond__InvalidReserveToken",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "reason", type: "string" }],
    name: "MCV2_Bond__InvalidStepParams",
    type: "error"
  },
  { inputs: [], name: "MCV2_Bond__InvalidTokenAmount", type: "error" },
  {
    inputs: [{ internalType: "string", name: "reason", type: "string" }],
    name: "MCV2_Bond__InvalidTokenCreationParams",
    type: "error"
  },
  { inputs: [], name: "MCV2_Bond__PermissionDenied", type: "error" },
  { inputs: [], name: "MCV2_Bond__SlippageLimitExceeded", type: "error" },
  { inputs: [], name: "MCV2_Bond__TokenNotFound", type: "error" },
  { inputs: [], name: "MCV2_Bond__TokenSymbolAlreadyExists", type: "error" },
  { inputs: [], name: "MCV2_Royalty__InvalidParams", type: "error" },
  { inputs: [], name: "MCV2_Royalty__NothingToClaim", type: "error" },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [
      { internalType: "uint8", name: "bits", type: "uint8" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "SafeCastOverflowedUintDowncast",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "creator",
        type: "address"
      }
    ],
    name: "BondCreatorUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      {
        indexed: false,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountBurned",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "reserveToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "refundAmount",
        type: "uint256"
      }
    ],
    name: "Burn",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "CreationFeeUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "user", type: "address" },
      {
        indexed: false,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amountMinted",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "reserveToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "reserveAmount",
        type: "uint256"
      }
    ],
    name: "Mint",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      { indexed: false, internalType: "string", name: "name", type: "string" },
      {
        indexed: false,
        internalType: "string",
        name: "symbol",
        type: "string"
      },
      { indexed: false, internalType: "string", name: "uri", type: "string" },
      {
        indexed: true,
        internalType: "address",
        name: "reserveToken",
        type: "address"
      }
    ],
    name: "MultiTokenCreated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "protocolBeneficiary",
        type: "address"
      }
    ],
    name: "ProtocolBeneficiaryUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "user", type: "address" },
      {
        indexed: false,
        internalType: "address",
        name: "reserveToken",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "RoyaltyClaimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "uint256",
        name: "ratio",
        type: "uint256"
      }
    ],
    name: "RoyaltyRangeUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      { indexed: false, internalType: "string", name: "name", type: "string" },
      {
        indexed: false,
        internalType: "string",
        name: "symbol",
        type: "string"
      },
      {
        indexed: true,
        internalType: "address",
        name: "reserveToken",
        type: "address"
      }
    ],
    name: "TokenCreated",
    type: "event"
  },
  {
    inputs: [],
    name: "BURN_ADDRESS",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "tokensToBurn", type: "uint256" },
      { internalType: "uint256", name: "minRefund", type: "uint256" },
      { internalType: "address", name: "receiver", type: "address" }
    ],
    name: "burn",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "reserveToken", type: "address" }],
    name: "burnRoyalties",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "reserveToken", type: "address" }],
    name: "claimRoyalties",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "string", name: "name", type: "string" },
          { internalType: "string", name: "symbol", type: "string" },
          { internalType: "string", name: "uri", type: "string" }
        ],
        internalType: "struct MCV2_Bond.MultiTokenParams",
        name: "tp",
        type: "tuple"
      },
      {
        components: [
          { internalType: "uint16", name: "mintRoyalty", type: "uint16" },
          { internalType: "uint16", name: "burnRoyalty", type: "uint16" },
          { internalType: "address", name: "reserveToken", type: "address" },
          { internalType: "uint128", name: "maxSupply", type: "uint128" },
          { internalType: "uint128[]", name: "stepRanges", type: "uint128[]" },
          { internalType: "uint128[]", name: "stepPrices", type: "uint128[]" }
        ],
        internalType: "struct MCV2_Bond.BondParams",
        name: "bp",
        type: "tuple"
      }
    ],
    name: "createMultiToken",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "string", name: "name", type: "string" },
          { internalType: "string", name: "symbol", type: "string" }
        ],
        internalType: "struct MCV2_Bond.TokenParams",
        name: "tp",
        type: "tuple"
      },
      {
        components: [
          { internalType: "uint16", name: "mintRoyalty", type: "uint16" },
          { internalType: "uint16", name: "burnRoyalty", type: "uint16" },
          { internalType: "address", name: "reserveToken", type: "address" },
          { internalType: "uint128", name: "maxSupply", type: "uint128" },
          { internalType: "uint128[]", name: "stepRanges", type: "uint128[]" },
          { internalType: "uint128[]", name: "stepPrices", type: "uint128[]" }
        ],
        internalType: "struct MCV2_Bond.BondParams",
        name: "bp",
        type: "tuple"
      }
    ],
    name: "createToken",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "creationFee",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "exists",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "getDetail",
    outputs: [
      {
        components: [
          { internalType: "uint16", name: "mintRoyalty", type: "uint16" },
          { internalType: "uint16", name: "burnRoyalty", type: "uint16" },
          {
            components: [
              { internalType: "address", name: "creator", type: "address" },
              { internalType: "address", name: "token", type: "address" },
              { internalType: "uint8", name: "decimals", type: "uint8" },
              { internalType: "string", name: "symbol", type: "string" },
              { internalType: "string", name: "name", type: "string" },
              { internalType: "uint40", name: "createdAt", type: "uint40" },
              {
                internalType: "uint128",
                name: "currentSupply",
                type: "uint128"
              },
              { internalType: "uint128", name: "maxSupply", type: "uint128" },
              {
                internalType: "uint128",
                name: "priceForNextMint",
                type: "uint128"
              },
              {
                internalType: "address",
                name: "reserveToken",
                type: "address"
              },
              { internalType: "uint8", name: "reserveDecimals", type: "uint8" },
              { internalType: "string", name: "reserveSymbol", type: "string" },
              { internalType: "string", name: "reserveName", type: "string" },
              {
                internalType: "uint256",
                name: "reserveBalance",
                type: "uint256"
              }
            ],
            internalType: "struct MCV2_Bond.BondInfo",
            name: "info",
            type: "tuple"
          },
          {
            components: [
              { internalType: "uint128", name: "rangeTo", type: "uint128" },
              { internalType: "uint128", name: "price", type: "uint128" }
            ],
            internalType: "struct MCV2_Bond.BondStep[]",
            name: "steps",
            type: "tuple[]"
          }
        ],
        internalType: "struct MCV2_Bond.BondDetail",
        name: "detail",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "start", type: "uint256" },
      { internalType: "uint256", name: "stop", type: "uint256" }
    ],
    name: "getList",
    outputs: [
      {
        components: [
          { internalType: "address", name: "creator", type: "address" },
          { internalType: "address", name: "token", type: "address" },
          { internalType: "uint8", name: "decimals", type: "uint8" },
          { internalType: "string", name: "symbol", type: "string" },
          { internalType: "string", name: "name", type: "string" },
          { internalType: "uint40", name: "createdAt", type: "uint40" },
          { internalType: "uint128", name: "currentSupply", type: "uint128" },
          { internalType: "uint128", name: "maxSupply", type: "uint128" },
          {
            internalType: "uint128",
            name: "priceForNextMint",
            type: "uint128"
          },
          { internalType: "address", name: "reserveToken", type: "address" },
          { internalType: "uint8", name: "reserveDecimals", type: "uint8" },
          { internalType: "string", name: "reserveSymbol", type: "string" },
          { internalType: "string", name: "reserveName", type: "string" },
          { internalType: "uint256", name: "reserveBalance", type: "uint256" }
        ],
        internalType: "struct MCV2_Bond.BondInfo[]",
        name: "info",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "tokensToBurn", type: "uint256" }
    ],
    name: "getRefundForTokens",
    outputs: [
      { internalType: "uint256", name: "refundAmount", type: "uint256" },
      { internalType: "uint256", name: "royalty", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "tokensToMint", type: "uint256" }
    ],
    name: "getReserveForToken",
    outputs: [
      { internalType: "uint256", name: "reserveAmount", type: "uint256" },
      { internalType: "uint256", name: "royalty", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "wallet", type: "address" },
      { internalType: "address", name: "reserveToken", type: "address" }
    ],
    name: "getRoyaltyInfo",
    outputs: [
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "getSteps",
    outputs: [
      {
        components: [
          { internalType: "uint128", name: "rangeTo", type: "uint128" },
          { internalType: "uint128", name: "price", type: "uint128" }
        ],
        internalType: "struct MCV2_Bond.BondStep[]",
        name: "",
        type: "tuple[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "creator", type: "address" },
      { internalType: "uint256", name: "start", type: "uint256" },
      { internalType: "uint256", name: "stop", type: "uint256" }
    ],
    name: "getTokensByCreator",
    outputs: [{ internalType: "address[]", name: "addresses", type: "address[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "reserveToken", type: "address" },
      { internalType: "uint256", name: "start", type: "uint256" },
      { internalType: "uint256", name: "stop", type: "uint256" }
    ],
    name: "getTokensByReserveToken",
    outputs: [{ internalType: "address[]", name: "addresses", type: "address[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "maxRoyaltyRange",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "maxSupply",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "tokensToMint", type: "uint256" },
      { internalType: "uint256", name: "maxReserveAmount", type: "uint256" },
      { internalType: "address", name: "receiver", type: "address" }
    ],
    name: "mint",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "priceForNextMint",
    outputs: [{ internalType: "uint128", name: "", type: "uint128" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "protocolBeneficiary",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "", type: "address" }],
    name: "tokenBond",
    outputs: [
      { internalType: "address", name: "creator", type: "address" },
      { internalType: "uint16", name: "mintRoyalty", type: "uint16" },
      { internalType: "uint16", name: "burnRoyalty", type: "uint16" },
      { internalType: "uint40", name: "createdAt", type: "uint40" },
      { internalType: "address", name: "reserveToken", type: "address" },
      { internalType: "uint256", name: "reserveBalance", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "tokenCount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "tokens",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "address", name: "creator", type: "address" }
    ],
    name: "updateBondCreator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "amount", type: "uint256" }],
    name: "updateCreationFee",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "ratio", type: "uint256" }],
    name: "updateMaxRoyaltyRange",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "protocolBeneficiary_",
        type: "address"
      }
    ],
    name: "updateProtocolBeneficiary",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "userTokenRoyaltyBalance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" }
    ],
    name: "userTokenRoyaltyClaimed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "version",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "pure",
    type: "function"
  }
];

const ERC1155_ABI = [
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint256", name: "balance", type: "uint256" },
      { internalType: "uint256", name: "needed", type: "uint256" },
      { internalType: "uint256", name: "tokenId", type: "uint256" }
    ],
    name: "ERC1155InsufficientBalance",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "approver", type: "address" }],
    name: "ERC1155InvalidApprover",
    type: "error"
  },
  {
    inputs: [
      { internalType: "uint256", name: "idsLength", type: "uint256" },
      { internalType: "uint256", name: "valuesLength", type: "uint256" }
    ],
    name: "ERC1155InvalidArrayLength",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "operator", type: "address" }],
    name: "ERC1155InvalidOperator",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "receiver", type: "address" }],
    name: "ERC1155InvalidReceiver",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "sender", type: "address" }],
    name: "ERC1155InvalidSender",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "address", name: "owner", type: "address" }
    ],
    name: "ERC1155MissingApprovalForAll",
    type: "error"
  },
  { inputs: [], name: "MCV2_MultiToken__AlreadyInitialized", type: "error" },
  {
    inputs: [],
    name: "MCV2_MultiToken__BurnAmountExceedsTotalSupply",
    type: "error"
  },
  { inputs: [], name: "MCV2_MultiToken__NotApproved", type: "error" },
  { inputs: [], name: "MCV2_MultiToken__PermissionDenied", type: "error" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      { indexed: false, internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "ids",
        type: "uint256[]"
      },
      {
        indexed: false,
        internalType: "uint256[]",
        name: "values",
        type: "uint256[]"
      }
    ],
    name: "TransferBatch",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      { indexed: false, internalType: "uint256", name: "id", type: "uint256" },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "TransferSingle",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: false, internalType: "string", name: "value", type: "string" },
      { indexed: true, internalType: "uint256", name: "id", type: "uint256" }
    ],
    name: "URI",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "uint256", name: "id", type: "uint256" }
    ],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address[]", name: "accounts", type: "address[]" },
      { internalType: "uint256[]", name: "ids", type: "uint256[]" }
    ],
    name: "balanceOfBatch",
    outputs: [{ internalType: "uint256[]", name: "", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "bond",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "burnByBond",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "contractURI",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [
      { internalType: "string", name: "name_", type: "string" },
      { internalType: "string", name: "symbol_", type: "string" },
      { internalType: "string", name: "uri_", type: "string" }
    ],
    name: "init",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "address", name: "operator", type: "address" }
    ],
    name: "isApprovedForAll",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "mintByBond",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256[]", name: "ids", type: "uint256[]" },
      { internalType: "uint256[]", name: "values", type: "uint256[]" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "safeBatchTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "id", type: "uint256" },
      { internalType: "uint256", name: "value", type: "uint256" },
      { internalType: "bytes", name: "data", type: "bytes" }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "operator", type: "address" },
      { internalType: "bool", name: "approved", type: "bool" }
    ],
    name: "setApprovalForAll",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "bytes4", name: "interfaceId", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "uri",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  }
];

const ERC20_ABI = [
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "allowance", type: "uint256" },
      { internalType: "uint256", name: "needed", type: "uint256" }
    ],
    name: "ERC20InsufficientAllowance",
    type: "error"
  },
  {
    inputs: [
      { internalType: "address", name: "sender", type: "address" },
      { internalType: "uint256", name: "balance", type: "uint256" },
      { internalType: "uint256", name: "needed", type: "uint256" }
    ],
    name: "ERC20InsufficientBalance",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "approver", type: "address" }],
    name: "ERC20InvalidApprover",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "receiver", type: "address" }],
    name: "ERC20InvalidReceiver",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "sender", type: "address" }],
    name: "ERC20InvalidSender",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "spender", type: "address" }],
    name: "ERC20InvalidSpender",
    type: "error"
  },
  { inputs: [], name: "MCV2_Token__AlreadyInitialized", type: "error" },
  { inputs: [], name: "MCV2_Token__PermissionDenied", type: "error" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "spender",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Approval",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      { indexed: true, internalType: "address", name: "from", type: "address" },
      { indexed: true, internalType: "address", name: "to", type: "address" },
      {
        indexed: false,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "address", name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "spender", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "bond",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "account", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "burnByBond",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "decimals",
    outputs: [{ internalType: "uint8", name: "", type: "uint8" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "string", name: "name_", type: "string" },
      { internalType: "string", name: "symbol_", type: "string" }
    ],
    name: "init",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "amount", type: "uint256" }
    ],
    name: "mintByBond",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "name",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "symbol",
    outputs: [{ internalType: "string", name: "", type: "string" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "totalSupply",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "from", type: "address" },
      { internalType: "address", name: "to", type: "address" },
      { internalType: "uint256", name: "value", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "nonpayable",
    type: "function"
  }
];

const LOCKER_ABI = [
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "LockUp__AlreadyClaimed", type: "error" },
  { inputs: [], name: "LockUp__InvalidPaginationParameters", type: "error" },
  {
    inputs: [{ internalType: "string", name: "param", type: "string" }],
    name: "LockUp__InvalidParams",
    type: "error"
  },
  { inputs: [], name: "LockUp__NotYetUnlocked", type: "error" },
  { inputs: [], name: "LockUp__PermissionDenied", type: "error" },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "lockUpId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      { indexed: false, internalType: "bool", name: "isERC20", type: "bool" },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint40",
        name: "unlockTime",
        type: "uint40"
      }
    ],
    name: "LockedUp",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "lockUpId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      { indexed: false, internalType: "bool", name: "isERC20", type: "bool" },
      {
        indexed: true,
        internalType: "address",
        name: "receiver",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Unlocked",
    type: "event"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "bool", name: "isERC20", type: "bool" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "uint40", name: "unlockTime", type: "uint40" },
      { internalType: "address", name: "receiver", type: "address" },
      { internalType: "string", name: "title", type: "string" }
    ],
    name: "createLockUp",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "receiver", type: "address" },
      { internalType: "uint256", name: "start", type: "uint256" },
      { internalType: "uint256", name: "stop", type: "uint256" }
    ],
    name: "getLockUpIdsByReceiver",
    outputs: [{ internalType: "uint256[]", name: "ids", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "start", type: "uint256" },
      { internalType: "uint256", name: "stop", type: "uint256" }
    ],
    name: "getLockUpIdsByToken",
    outputs: [{ internalType: "uint256[]", name: "ids", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lockUpCount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "lockUps",
    outputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "bool", name: "isERC20", type: "bool" },
      { internalType: "uint40", name: "unlockTime", type: "uint40" },
      { internalType: "bool", name: "unlocked", type: "bool" },
      { internalType: "uint256", name: "amount", type: "uint256" },
      { internalType: "address", name: "receiver", type: "address" },
      { internalType: "string", name: "title", type: "string" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "", type: "bytes" }
    ],
    name: "onERC1155Received",
    outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "lockUpId", type: "uint256" }],
    name: "unlock",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

const MERKLE_ABI = [
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "MerkleDistributor__AlreadyClaimed", type: "error" },
  { inputs: [], name: "MerkleDistributor__AlreadyRefunded", type: "error" },
  { inputs: [], name: "MerkleDistributor__Finished", type: "error" },
  { inputs: [], name: "MerkleDistributor__InvalidCaller", type: "error" },
  {
    inputs: [],
    name: "MerkleDistributor__InvalidPaginationParameters",
    type: "error"
  },
  {
    inputs: [{ internalType: "string", name: "param", type: "string" }],
    name: "MerkleDistributor__InvalidParams",
    type: "error"
  },
  { inputs: [], name: "MerkleDistributor__InvalidProof", type: "error" },
  {
    inputs: [],
    name: "MerkleDistributor__NoClaimableTokensLeft",
    type: "error"
  },
  { inputs: [], name: "MerkleDistributor__NotStarted", type: "error" },
  { inputs: [], name: "MerkleDistributor__NothingToRefund", type: "error" },
  { inputs: [], name: "MerkleDistributor__PermissionDenied", type: "error" },
  { inputs: [], name: "MerkleDistributor__Refunded", type: "error" },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "distributionId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "address",
        name: "account",
        type: "address"
      }
    ],
    name: "Claimed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "distributionId",
        type: "uint256"
      },
      {
        indexed: true,
        internalType: "address",
        name: "token",
        type: "address"
      },
      { indexed: false, internalType: "bool", name: "isERC20", type: "bool" },
      {
        indexed: false,
        internalType: "uint40",
        name: "startTime",
        type: "uint40"
      }
    ],
    name: "Created",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "uint256",
        name: "distributionId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      }
    ],
    name: "Refunded",
    type: "event"
  },
  {
    inputs: [
      { internalType: "uint256", name: "distributionId", type: "uint256" },
      { internalType: "bytes32[]", name: "merkleProof", type: "bytes32[]" }
    ],
    name: "claim",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "bool", name: "isERC20", type: "bool" },
      { internalType: "uint176", name: "amountPerClaim", type: "uint176" },
      { internalType: "uint40", name: "walletCount", type: "uint40" },
      { internalType: "uint40", name: "startTime", type: "uint40" },
      { internalType: "uint40", name: "endTime", type: "uint40" },
      { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
      { internalType: "string", name: "title", type: "string" },
      { internalType: "string", name: "ipfsCID", type: "string" }
    ],
    name: "createDistribution",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "distributionCount",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    name: "distributions",
    outputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "bool", name: "isERC20", type: "bool" },
      { internalType: "uint40", name: "walletCount", type: "uint40" },
      { internalType: "uint40", name: "claimedCount", type: "uint40" },
      { internalType: "uint176", name: "amountPerClaim", type: "uint176" },
      { internalType: "uint40", name: "startTime", type: "uint40" },
      { internalType: "uint40", name: "endTime", type: "uint40" },
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "uint40", name: "refundedAt", type: "uint40" },
      { internalType: "bytes32", name: "merkleRoot", type: "bytes32" },
      { internalType: "string", name: "title", type: "string" },
      { internalType: "string", name: "ipfsCID", type: "string" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "distributionId", type: "uint256" }],
    name: "getAmountClaimed",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "distributionId", type: "uint256" }],
    name: "getAmountLeft",
    outputs: [{ internalType: "uint256", name: "", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "owner", type: "address" },
      { internalType: "uint256", name: "start", type: "uint256" },
      { internalType: "uint256", name: "stop", type: "uint256" }
    ],
    name: "getDistributionIdsByOwner",
    outputs: [{ internalType: "uint256[]", name: "ids", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "start", type: "uint256" },
      { internalType: "uint256", name: "stop", type: "uint256" }
    ],
    name: "getDistributionIdsByToken",
    outputs: [{ internalType: "uint256[]", name: "ids", type: "uint256[]" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "distributionId", type: "uint256" },
      { internalType: "address", name: "wallet", type: "address" }
    ],
    name: "isClaimed",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "distributionId", type: "uint256" }],
    name: "isWhitelistOnly",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "uint256", name: "distributionId", type: "uint256" },
      { internalType: "address", name: "wallet", type: "address" },
      { internalType: "bytes32[]", name: "merkleProof", type: "bytes32[]" }
    ],
    name: "isWhitelisted",
    outputs: [{ internalType: "bool", name: "", type: "bool" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "", type: "address" },
      { internalType: "address", name: "", type: "address" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "uint256", name: "", type: "uint256" },
      { internalType: "bytes", name: "", type: "bytes" }
    ],
    name: "onERC1155Received",
    outputs: [{ internalType: "bytes4", name: "", type: "bytes4" }],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "distributionId", type: "uint256" }],
    name: "refund",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

const ONEINCH_ABI = [
  {
    inputs: [
      {
        internalType: "contract MultiWrapper",
        name: "_multiWrapper",
        type: "address"
      },
      {
        internalType: "contract IOracle[]",
        name: "existingOracles",
        type: "address[]"
      },
      {
        internalType: "enum OffchainOracle.OracleType[]",
        name: "oracleTypes",
        type: "uint8[]"
      },
      {
        internalType: "contract IERC20[]",
        name: "existingConnectors",
        type: "address[]"
      },
      { internalType: "contract IERC20", name: "wBase", type: "address" },
      { internalType: "address", name: "owner", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  { inputs: [], name: "ArraysLengthMismatch", type: "error" },
  { inputs: [], name: "ConnectorAlreadyAdded", type: "error" },
  { inputs: [], name: "InvalidOracleTokenKind", type: "error" },
  { inputs: [], name: "OracleAlreadyAdded", type: "error" },
  { inputs: [], name: "SameTokens", type: "error" },
  { inputs: [], name: "TooBigThreshold", type: "error" },
  { inputs: [], name: "UnknownConnector", type: "error" },
  { inputs: [], name: "UnknownOracle", type: "error" },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract IERC20",
        name: "connector",
        type: "address"
      }
    ],
    name: "ConnectorAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract IERC20",
        name: "connector",
        type: "address"
      }
    ],
    name: "ConnectorRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract MultiWrapper",
        name: "multiWrapper",
        type: "address"
      }
    ],
    name: "MultiWrapperUpdated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract IOracle",
        name: "oracle",
        type: "address"
      },
      {
        indexed: false,
        internalType: "enum OffchainOracle.OracleType",
        name: "oracleType",
        type: "uint8"
      }
    ],
    name: "OracleAdded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "contract IOracle",
        name: "oracle",
        type: "address"
      },
      {
        indexed: false,
        internalType: "enum OffchainOracle.OracleType",
        name: "oracleType",
        type: "uint8"
      }
    ],
    name: "OracleRemoved",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    inputs: [{ internalType: "contract IERC20", name: "connector", type: "address" }],
    name: "addConnector",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IOracle", name: "oracle", type: "address" },
      {
        internalType: "enum OffchainOracle.OracleType",
        name: "oracleKind",
        type: "uint8"
      }
    ],
    name: "addOracle",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "connectors",
    outputs: [
      {
        internalType: "contract IERC20[]",
        name: "allConnectors",
        type: "address[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IERC20", name: "srcToken", type: "address" },
      { internalType: "contract IERC20", name: "dstToken", type: "address" },
      { internalType: "bool", name: "useWrappers", type: "bool" }
    ],
    name: "getRate",
    outputs: [{ internalType: "uint256", name: "weightedRate", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IERC20", name: "srcToken", type: "address" },
      { internalType: "bool", name: "useSrcWrappers", type: "bool" }
    ],
    name: "getRateToEth",
    outputs: [{ internalType: "uint256", name: "weightedRate", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IERC20", name: "srcToken", type: "address" },
      { internalType: "bool", name: "useSrcWrappers", type: "bool" },
      {
        internalType: "contract IERC20[]",
        name: "customConnectors",
        type: "address[]"
      },
      { internalType: "uint256", name: "thresholdFilter", type: "uint256" }
    ],
    name: "getRateToEthWithCustomConnectors",
    outputs: [{ internalType: "uint256", name: "weightedRate", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IERC20", name: "srcToken", type: "address" },
      { internalType: "bool", name: "useSrcWrappers", type: "bool" },
      { internalType: "uint256", name: "thresholdFilter", type: "uint256" }
    ],
    name: "getRateToEthWithThreshold",
    outputs: [{ internalType: "uint256", name: "weightedRate", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IERC20", name: "srcToken", type: "address" },
      { internalType: "contract IERC20", name: "dstToken", type: "address" },
      { internalType: "bool", name: "useWrappers", type: "bool" },
      {
        internalType: "contract IERC20[]",
        name: "customConnectors",
        type: "address[]"
      },
      { internalType: "uint256", name: "thresholdFilter", type: "uint256" }
    ],
    name: "getRateWithCustomConnectors",
    outputs: [{ internalType: "uint256", name: "weightedRate", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IERC20", name: "srcToken", type: "address" },
      { internalType: "contract IERC20", name: "dstToken", type: "address" },
      { internalType: "bool", name: "useWrappers", type: "bool" },
      { internalType: "uint256", name: "thresholdFilter", type: "uint256" }
    ],
    name: "getRateWithThreshold",
    outputs: [{ internalType: "uint256", name: "weightedRate", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "multiWrapper",
    outputs: [{ internalType: "contract MultiWrapper", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "oracles",
    outputs: [
      {
        internalType: "contract IOracle[]",
        name: "allOracles",
        type: "address[]"
      },
      {
        internalType: "enum OffchainOracle.OracleType[]",
        name: "oracleTypes",
        type: "uint8[]"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "contract IERC20", name: "connector", type: "address" }],
    name: "removeConnector",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "contract IOracle", name: "oracle", type: "address" },
      {
        internalType: "enum OffchainOracle.OracleType",
        name: "oracleKind",
        type: "uint8"
      }
    ],
    name: "removeOracle",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract MultiWrapper",
        name: "_multiWrapper",
        type: "address"
      }
    ],
    name: "setMultiWrapper",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

const ZAP_ABI = [
  {
    inputs: [
      { internalType: "address", name: "bondAddress", type: "address" },
      { internalType: "address", name: "wethAddress", type: "address" }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    inputs: [{ internalType: "address", name: "target", type: "address" }],
    name: "AddressEmptyCode",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "AddressInsufficientBalance",
    type: "error"
  },
  { inputs: [], name: "FailedInnerCall", type: "error" },
  { inputs: [], name: "MCV2_ZapV1__EthTransferFailed", type: "error" },
  { inputs: [], name: "MCV2_ZapV1__InvalidReceiver", type: "error" },
  { inputs: [], name: "MCV2_ZapV1__ReserveIsNotWETH", type: "error" },
  { inputs: [], name: "MCV2_ZapV1__SlippageLimitExceeded", type: "error" },
  {
    inputs: [{ internalType: "address", name: "owner", type: "address" }],
    name: "OwnableInvalidOwner",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "account", type: "address" }],
    name: "OwnableUnauthorizedAccount",
    type: "error"
  },
  {
    inputs: [{ internalType: "address", name: "token", type: "address" }],
    name: "SafeERC20FailedOperation",
    type: "error"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previousOwner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "newOwner",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    inputs: [],
    name: "BOND",
    outputs: [{ internalType: "contract MCV2_Bond", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "WETH",
    outputs: [{ internalType: "contract IWETH", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "tokensToBurn", type: "uint256" },
      { internalType: "uint256", name: "minRefund", type: "uint256" },
      { internalType: "address", name: "receiver", type: "address" }
    ],
    name: "burnToEth",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "address", name: "token", type: "address" },
      { internalType: "uint256", name: "tokensToMint", type: "uint256" },
      { internalType: "address", name: "receiver", type: "address" }
    ],
    name: "mintWithEth",
    outputs: [],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [{ internalType: "address", name: "", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "renounceOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "receiver", type: "address" }],
    name: "rescueETH",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "newOwner", type: "address" }],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  { stateMutability: "payable", type: "receive" }
];

const SDK_CONTRACT_ADDRESSES = {
  ERC20: {
    [chains.mainnet.id]: "0xAa70bC79fD1cB4a6FBA717018351F0C3c64B79Df",
    [chains.optimism.id]: "0xAa70bC79fD1cB4a6FBA717018351F0C3c64B79Df",
    [chains.arbitrum.id]: "0xAa70bC79fD1cB4a6FBA717018351F0C3c64B79Df",
    [chains.avalanche.id]: "0x5DaE94e149CF2112Ec625D46670047814aA9aC2a",
    [chains.polygon.id]: "0xAa70bC79fD1cB4a6FBA717018351F0C3c64B79Df",
    [chains.bsc.id]: "0xAa70bC79fD1cB4a6FBA717018351F0C3c64B79Df",
    [chains.base.id]: "0xAa70bC79fD1cB4a6FBA717018351F0C3c64B79Df",
    [chains.sepolia.id]: "0x749bA94344521727f55a3007c777FbeB5F52C2Eb",
    [chains.blast.id]: "0x1349A9DdEe26Fe16D0D44E35B3CB9B0CA18213a4",
    [chains.blastSepolia.id]: "0x37F540de37afE8bDf6C722d87CB019F30e5E406a",
    [chains.avalancheFuji.id]: "0xAD5a113ee65F30269f7558f96483126B1FB60c4E"
  },
  ERC1155: {
    [chains.mainnet.id]: "0x6c61918eECcC306D35247338FDcf025af0f6120A",
    [chains.optimism.id]: "0x6c61918eECcC306D35247338FDcf025af0f6120A",
    [chains.arbitrum.id]: "0x6c61918eECcC306D35247338FDcf025af0f6120A",
    [chains.avalanche.id]: "0x621c335b4BD8f2165E120DC70d3AfcAfc6628681",
    [chains.polygon.id]: "0x6c61918eECcC306D35247338FDcf025af0f6120A",
    [chains.bsc.id]: "0x6c61918eECcC306D35247338FDcf025af0f6120A",
    [chains.base.id]: "0x6c61918eECcC306D35247338FDcf025af0f6120A",
    [chains.sepolia.id]: "0x3cABE5125C5D8922c5f38c5b779F6E96F563cdc0",
    [chains.blast.id]: "0x5DaE94e149CF2112Ec625D46670047814aA9aC2a",
    [chains.blastSepolia.id]: "0x4bF67e5C9baD43DD89dbe8fCAD3c213C868fe881",
    [chains.avalancheFuji.id]: "0xB43826E079dFB2e2b48a0a473Efc7F1fe6391763"
  },
  BOND: {
    [chains.mainnet.id]: "0xc5a076cad94176c2996B32d8466Be1cE757FAa27",
    [chains.optimism.id]: "0xc5a076cad94176c2996B32d8466Be1cE757FAa27",
    [chains.arbitrum.id]: "0xc5a076cad94176c2996B32d8466Be1cE757FAa27",
    [chains.avalanche.id]: "0x3Fd5B4DcDa968C8e22898523f5343177F94ccfd1",
    [chains.polygon.id]: "0xc5a076cad94176c2996B32d8466Be1cE757FAa27",
    [chains.bsc.id]: "0xc5a076cad94176c2996B32d8466Be1cE757FAa27",
    [chains.base.id]: "0xc5a076cad94176c2996B32d8466Be1cE757FAa27",
    [chains.sepolia.id]: "0x8dce343A86Aa950d539eeE0e166AFfd0Ef515C0c",
    [chains.blast.id]: "0x621c335b4BD8f2165E120DC70d3AfcAfc6628681",
    [chains.blastSepolia.id]: "0x5dfA75b0185efBaEF286E80B847ce84ff8a62C2d",
    [chains.avalancheFuji.id]: "0x20fBC8a650d75e4C2Dab8b7e85C27135f0D64e89"
  },
  ZAP: {
    [chains.mainnet.id]: "0x91523b39813F3F4E406ECe406D0bEAaA9dE251fa",
    [chains.optimism.id]: "0x91523b39813F3F4E406ECe406D0bEAaA9dE251fa",
    [chains.arbitrum.id]: "0x91523b39813F3F4E406ECe406D0bEAaA9dE251fa",
    [chains.avalanche.id]: "0x29b0E6D2C2884aEa3FB4CB5dD1C7002A8E10c724",
    [chains.polygon.id]: "0x91523b39813F3F4E406ECe406D0bEAaA9dE251fa",
    [chains.bsc.id]: "0x91523b39813F3F4E406ECe406D0bEAaA9dE251fa",
    [chains.base.id]: "0x91523b39813F3F4E406ECe406D0bEAaA9dE251fa",
    [chains.sepolia.id]: "0x1Bf3183acc57571BecAea0E238d6C3A4d00633da",
    [chains.blast.id]: "0x06FD26c092Db44E5491abB7cDC580CE24D93030c",
    [chains.blastSepolia.id]: "0x40c7DC399e01029a51cAb316f8Bca7D20DE31bad",
    [chains.avalancheFuji.id]: "0x60432191893c4F742205a2C834817a1891feC435"
  },
  LOCKER: {
    [chains.mainnet.id]: "0xA3dCf3Ca587D9929d540868c924f208726DC9aB6",
    [chains.optimism.id]: "0xA3dCf3Ca587D9929d540868c924f208726DC9aB6",
    [chains.arbitrum.id]: "0xA3dCf3Ca587D9929d540868c924f208726DC9aB6",
    [chains.avalanche.id]: "0x5b64cECC5cF3E4B1A668Abd895D16BdDC0c77a17",
    [chains.polygon.id]: "0xA3dCf3Ca587D9929d540868c924f208726DC9aB6",
    [chains.bsc.id]: "0xA3dCf3Ca587D9929d540868c924f208726DC9aB6",
    [chains.base.id]: "0xA3dCf3Ca587D9929d540868c924f208726DC9aB6",
    [chains.sepolia.id]: "0x7c204B1B03A88D24088941068f6DFC809f2fd022",
    [chains.blast.id]: "0x3Fd5B4DcDa968C8e22898523f5343177F94ccfd1",
    [chains.blastSepolia.id]: "0x2c6B3fe4D6de27363cFEC95f703889EaF6b770fB",
    [chains.avalancheFuji.id]: "0x789771E410527691729e54A84103594ee6Be6C3C"
  },
  MERKLE: {
    [chains.mainnet.id]: "0x1349A9DdEe26Fe16D0D44E35B3CB9B0CA18213a4",
    [chains.optimism.id]: "0x1349A9DdEe26Fe16D0D44E35B3CB9B0CA18213a4",
    [chains.arbitrum.id]: "0x1349A9DdEe26Fe16D0D44E35B3CB9B0CA18213a4",
    [chains.avalanche.id]: "0x841A2bD2fc97DCB865b4Ddb352540148Bad2dB09",
    [chains.polygon.id]: "0x1349A9DdEe26Fe16D0D44E35B3CB9B0CA18213a4",
    [chains.bsc.id]: "0x1349A9DdEe26Fe16D0D44E35B3CB9B0CA18213a4",
    [chains.base.id]: "0x1349A9DdEe26Fe16D0D44E35B3CB9B0CA18213a4",
    [chains.sepolia.id]: "0x0CD940395566d509168977Cf10E5296302efA57A",
    [chains.blast.id]: "0x29b0E6D2C2884aEa3FB4CB5dD1C7002A8E10c724",
    [chains.blastSepolia.id]: "0xCbb23973235feA43E62C41a0c67717a92a2467f2",
    [chains.avalancheFuji.id]: "0x6d1f4ecd17ddA7fb39C56Da566b66d63f06671d9"
  },
  ONEINCH: {
    [chains.mainnet.id]: "0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8",
    [chains.optimism.id]: "0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8",
    [chains.arbitrum.id]: "0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8",
    [chains.avalanche.id]: "0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8",
    [chains.polygon.id]: "0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8",
    [chains.bsc.id]: "0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8",
    [chains.base.id]: "0x0AdDd25a91563696D8567Df78D5A01C9a991F9B8",
    [chains.sepolia.id]: "0x",
    [chains.blast.id]: "0x",
    [chains.blastSepolia.id]: "0x",
    [chains.avalancheFuji.id]: "0x"
  }
};
function getMintClubContractAddress(contractName, chainId) {
  let contractAddress = SDK_CONTRACT_ADDRESSES[contractName][chainId];
  if (process.env.NODE_ENV === "hardhat") {
    contractAddress = global.mcv2Hardhat?.[contractName]?.[chainId];
  }
  if (!contractAddress) {
    throw new Error(`Contract address for ${contractName} on chain ${chainId} not found`);
  }
  return contractAddress;
}

const CHAINS = [
  {
    id: chains.mainnet.id,
    name: "Ethereum",
    icon: "https://mint.club/assets/networks/ethereum@2x.png",
    color: "#627EEA",
    openseaSlug: "ethereum",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.mainnet.id))
  },
  {
    id: chains.base.id,
    name: "Base",
    icon: "https://mint.club/assets/networks/base@2x.png",
    color: "#0052FF",
    openseaSlug: "base",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.base.id))
  },
  {
    id: chains.blast.id,
    name: "Blast",
    icon: "https://mint.club/assets/networks/blast@2x.png",
    color: "#FCFC03",
    openseaSlug: "blast",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.blast.id))
  },
  {
    id: chains.optimism.id,
    name: "Optimism",
    icon: "https://mint.club/assets/networks/optimism@2x.png",
    color: "#FF0420",
    openseaSlug: "optimism",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.optimism.id))
  },
  {
    id: chains.arbitrum.id,
    name: "Arbitrum",
    icon: "https://mint.club/assets/networks/arbitrum@2x.png",
    color: "#12AAFF",
    openseaSlug: "arbitrum",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.arbitrum.id))
  },
  {
    id: chains.avalanche.id,
    name: "Avalanche",
    icon: "https://mint.club/assets/networks/avalanche@2x.png",
    color: "#E94143",
    openseaSlug: "avalanche",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.avalanche.id))
  },
  {
    id: chains.polygon.id,
    name: "Polygon",
    icon: "https://mint.club/assets/networks/polygon@2x.png",
    color: "#8247E5",
    openseaSlug: "matic",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.polygon.id))
  },
  {
    id: chains.bsc.id,
    name: "BNBChain",
    icon: "https://mint.club/assets/networks/bnb@2x.png",
    color: "#F0B90B",
    openseaSlug: "bsc",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.bsc.id))
  },
  {
    id: chains.sepolia.id,
    name: "Sepolia",
    icon: "https://mint.club/assets/networks/ethereum@2x.png",
    color: "#627EEA",
    openseaSlug: "sepolia",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.sepolia.id)),
    isTestnet: true
  },
  {
    id: chains.blastSepolia.id,
    name: "BlastSepolia",
    icon: "https://mint.club/assets/networks/blast@2x.png",
    color: "#FCFC03",
    openseaSlug: "blast-sepolia",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.blastSepolia.id)),
    isTestnet: true
  },
  {
    id: chains.avalancheFuji.id,
    name: "AvalancheFuji",
    icon: "https://mint.club/assets/networks/avalanche@2x.png",
    color: "#E94143",
    openseaSlug: "avalanche-fuji",
    enabled: viem.isAddress(getMintClubContractAddress("BOND", chains.avalancheFuji.id)),
    isTestnet: true
  }
];
function chainIdToString(chainId) {
  const found = CHAINS.find((chain) => chain.id === chainId);
  if (!found)
    throw new ChainNotSupportedError(chainId);
  return found?.name?.toLowerCase();
}
function chainStringToId(name) {
  const found = CHAINS.find((chain) => chain?.name?.toLowerCase?.() === name?.toLowerCase?.());
  if (!found)
    throw new ChainNotSupportedError(name);
  return found.id;
}
function getChain(chainId) {
  const chain = Object.values(chains__namespace).find((c) => c.id === chainId);
  if (!chain) {
    throw new ChainNotSupportedError(chainId);
  }
  return chain;
}
const CHAIN_MAP = CHAINS.reduce((prev, curr) => {
  prev[curr.id] = curr;
  return prev;
}, {});
const CHAIN_NAME_ID_MAP = {
  sepolia: chains.sepolia.id
};

const RPCS = [
  {
    id: chains.mainnet.id,
    rpcs: [
      "https://eth.drpc.org",
      "https://eth.llamarpc.com",
      "https://eth-mainnet.nodereal.io/v1/1659dfb40aa24bbb8153a677b98064d7",
      // 'https://virginia.rpc.blxrbdn.com',
      // 'https://singapore.rpc.blxrbdn.com',
      // 'https://uk.rpc.blxrbdn.com',
      "https://rpc.ankr.com/eth",
      // 'https://eth-pokt.nodies.app',
      // 'https://ethereum.blockpi.network/v1/rpc/public',
      "https://ethereum.publicnode.com",
      "https://cloudflare-eth.com",
      // 'https://rpc.notadegen.com/eth',
      // 'https://eth.rpc.blxrbdn.com',
      // 'https://api.zan.top/node/v1/eth/mainnet/public',
      "https://api.zmok.io/mainnet/oaen6dy8ff6hju9k",
      "https://eth-mainnet.public.blastapi.io",
      "https://eth.merkle.io",
      "https://eth-mainnet.rpcfast.com?api_key=xbhWBI1Wkguk8SNMu1bvvLurPGLXmgwYeC4S6g2H7WdwFigZSmPWVZRxrskEQwIf",
      "https://api.securerpc.com/v1",
      "https://eth.meowrpc.com",
      "https://eth.nodeconnect.org",
      "https://rpc.mevblocker.io/fullprivacy",
      "https://rpc.mevblocker.io/noreverts",
      "https://rpc.mevblocker.io",
      "https://rpc.mevblocker.io/fast",
      "https://core.gashawk.io/rpc",
      "https://rpc.payload.de",
      "https://rpc.tornadoeth.cash/eth",
      "https://rpc.tornadoeth.cash/mev",
      // 'https://rpc.lokibuilder.xyz/wallet',
      "https://endpoints.omniatech.io/v1/eth/mainnet/public"
      // 'https://gateway.tenderly.co/public/mainnet',
      // 'https://mainnet.gateway.tenderly.co',
      // 'https://rpc.builder0x69.io',
      // 'https://eth.api.onfinality.io/public',
      // 'https://rpc.flashbots.net/fast',
      // 'https://rpc.blocknative.com/boost',
      // 'https://api.mycryptoapi.com/eth',
      // 'https://rpc.polysplit.cloud/v1/chain/1',
      // 'https://services.tokenview.io/vipapi/nodeservice/eth?apikey=qVHq2o6jpaakcw3lRstl',
      // 'https://eth-mainnet.diamondswap.org/rpc',
      // 'https://rpc.tenderly.co/fork/c63af728-a183-4cfb-b24e-a92801463484',
      // 'https://rpc.chain49.com/ethereum?api_key=14d1a8b86d8a4b4797938332394203dc',
      // 'https://rpc.eth.gateway.fm',
      // 'https://main-light.eth.linkpool.io',
      // 'https://ethereumnodelight.app.runonflux.io',
      // 'https://mainnet.eth.cloud.ava.do',
      // 'https://eth-mainnet.g.alchemy.com/v2/demo',
      // 'https://eth-mainnet-public.unifra.io',
      // 'https://openapi.bitstack.com/v1/wNFxbiJyQsSeLrX8RRCHi7NpRxrlErZk/DjShIqLishPCTB9HiMkPHXjUM9CNM9Na/ETH/mainnet',
      // 'https://rpc.flashbots.net',
      // 'https://1rpc.io/eth',
      // 'https://go.getblock.io/d7dab8149ec04390aaa923ff2768f914',
    ]
  },
  {
    id: chains.base.id,
    rpcs: [
      "https://base.drpc.org",
      "https://base-mainnet.public.blastapi.io",
      "https://base.publicnode.com",
      "https://base.llamarpc.com",
      // 'https://base.blockpi.network/v1/rpc/public',
      // 'https://mainnet.base.org',
      // 'https://developer-access-mainnet.base.org',
      // 'https://base-pokt.nodies.app',
      // 'https://endpoints.omniatech.io/v1/base/mainnet/public',
      // 'https://base.gateway.tenderly.co',
      // 'https://gateway.tenderly.co/public/base',
      "https://base.publicnode.com",
      "https://base-mainnet.public.blastapi.io"
      // 'https://base.api.onfinality.io/public',
      // 'https://rpc.notadegen.com/base',
      // 'https://base.meowrpc.com',
      // 'https://1rpc.io/base',
      // 'https://base-mainnet.diamondswap.org/rpc',
    ]
  },
  {
    id: chains.optimism.id,
    rpcs: [
      "https://optimism.drpc.org",
      "https://optimism.llamarpc.com",
      // 'https://op-pokt.nodies.app',
      // 'https://api.zan.top/node/v1/opt/mainnet/public',
      "https://endpoints.omniatech.io/v1/op/mainnet/public",
      "https://optimism.publicnode.com",
      "https://optimism-mainnet.public.blastapi.io",
      "https://rpc.tornadoeth.cash/optimism",
      "https://rpc.optimism.gateway.fm",
      // 'https://mainnet.optimism.io',
      "https://rpc.ankr.com/optimism",
      // 'https://gateway.tenderly.co/public/optimism',
      // 'https://optimism.api.onfinality.io/public',
      // 'https://optimism.gateway.tenderly.co',
      // 'https://optimism.meowrpc.com',
      // 'https://optimism.blockpi.network/v1/rpc/public',
      // 'https://opt-mainnet.g.alchemy.com/v2/demo',
      "https://1rpc.io/op"
    ]
  },
  {
    id: chains.arbitrum.id,
    rpcs: [
      "https://arbitrum.drpc.org",
      "https://arbitrum.llamarpc.com",
      // 'https://rpc.tornadoeth.cash/arbitrum',
      "https://arbitrum.meowrpc.com",
      "https://arbitrum-one.public.blastapi.io",
      "https://rpc.arb1.arbitrum.gateway.fm",
      "https://arb-pokt.nodies.app",
      // 'https://api.zan.top/node/v1/arb/one/public',
      "https://arbitrum-one.publicnode.com",
      "https://arb1.arbitrum.io/rpc",
      "https://rpc.ankr.com/arbitrum",
      "https://endpoints.omniatech.io/v1/arbitrum/one/public",
      // 'https://arb-mainnet-public.unifra.io',
      "https://arbitrum.blockpi.network/v1/rpc/public",
      // 'https://arb-mainnet.g.alchemy.com/v2/demo',
      "https://1rpc.io/arb"
    ]
  },
  {
    id: chains.polygon.id,
    rpcs: [
      "https://polygon.drpc.org",
      "https://polygon.llamarpc.com",
      // 'https://polygon-pokt.nodies.app',
      // 'https://polygon.blockpi.network/v1/rpc/public',
      // 'https://polygon.rpc.blxrbdn.com',
      "https://rpc-mainnet.matic.quiknode.pro",
      "https://polygon-bor.publicnode.com",
      "https://polygon-mainnet.rpcfast.com?api_key=xbhWBI1Wkguk8SNMu1bvvLurPGLXmgwYeC4S6g2H7WdwFigZSmPWVZRxrskEQwIf",
      "https://polygon-rpc.com",
      // 'https://api.zan.top/node/v1/polygon/mainnet/public',
      "https://rpc-mainnet.maticvigil.com",
      "https://polygon.meowrpc.com",
      "https://rpc.ankr.com/polygon",
      "https://endpoints.omniatech.io/v1/matic/mainnet/public",
      "https://rpc.tornadoeth.cash/polygon",
      // 'https://polygon.api.onfinality.io/public',
      "https://polygon-mainnet.public.blastapi.io",
      // 'https://polygon.gateway.tenderly.co',
      // 'https://gateway.tenderly.co/public/polygon',
      // 'https://matic-mainnet.chainstacklabs.com',
      // 'https://getblock.io/nodes/matic',
      // 'https://polygon-mainnet.g.alchemy.com/v2/demo',
      // 'https://polygon-mainnet-public.unifra.io',
      "https://1rpc.io/matic"
      // 'https://polygonapi.terminet.io/rpc',
      // 'https://matic-mainnet-archive-rpc.bwarelabs.com',
      // 'https://matic-mainnet-full-rpc.bwarelabs.com',
      // 'https://rpc-mainnet.matic.network',
    ]
  },
  {
    id: chains.bsc.id,
    rpcs: [
      "https://bsc-dataseed4.bnbchain.org",
      "https://binance.llamarpc.com",
      "https://bsc-dataseed2.defibit.io",
      "https://bsc-dataseed3.defibit.io",
      "https://bsc-dataseed4.defibit.io",
      "https://bsc-dataseed4.ninicoin.io",
      "https://bsc-dataseed3.bnbchain.org",
      "https://bsc-mainnet.nodereal.io/v1/64a9df0874fb4a93b9d0a3849de012d3",
      "https://binance.nodereal.io",
      "https://bsc-dataseed1.ninicoin.io",
      "https://bsc-dataseed2.ninicoin.io",
      "https://bsc-dataseed3.ninicoin.io",
      "https://bsc-dataseed1.defibit.io",
      "https://bsc-dataseed2.bnbchain.org",
      "https://bsc-dataseed.bnbchain.org",
      "https://bsc-dataseed1.bnbchain.org",
      // 'https://bsc.rpc.blxrbdn.com',
      "https://bsc.publicnode.com",
      "https://bsc-mainnet.public.blastapi.io",
      "https://bsc-mainnet.rpcfast.com?api_key=xbhWBI1Wkguk8SNMu1bvvLurPGLXmgwYeC4S6g2H7WdwFigZSmPWVZRxrskEQwIf",
      "https://bsc.meowrpc.com",
      // 'https://bnb.api.onfinality.io/public',
      "https://rpc-bsc.48.club",
      "https://koge-rpc-bsc.48.club",
      // 'https://bsc.drpc.org',
      "https://endpoints.omniatech.io/v1/bsc/mainnet/public",
      "https://bscrpc.com",
      "https://rpc.ankr.com/bsc",
      // 'https://bsc-pokt.nodies.app',
      // 'https://api.zan.top/node/v1/bsc/mainnet/public',
      "https://rpc.tornadoeth.cash/bsc"
      // 'https://services.tokenview.io/vipapi/nodeservice/bsc?apikey=qVHq2o6jpaakcw3lRstl',
      // 'https://bsc.blockpi.network/v1/rpc/public',
      // 'https://1rpc.io/bnb',
      // 'https://nodes.vefinetwork.org/smartchain',
      // 'https://bsc-dataseed6.dict.life',
    ]
  },
  {
    id: chains.avalanche.id,
    rpcs: [
      "https://avalanche.drpc.org",
      "https://rpc.tornadoeth.cash/avax",
      "https://rpc.ankr.com/avalanche",
      "https://ava-mainnet.public.blastapi.io/ext/bc/C/rpc",
      "https://avalanche-c-chain.publicnode.com",
      "https://avalanche.public-rpc.com",
      "https://endpoints.omniatech.io/v1/avax/mainnet/public",
      "https://api.avax.network/ext/bc/C/rpc"
      // 'https://api.zan.top/node/v1/avax/mainnet/public/ext/bc/C/rpc',
      // 'https://avax.meowrpc.com',
      // 'https://avalanche.api.onfinality.io/public/ext/bc/C/rpc',
      // 'https://avax-pokt.nodies.app/ext/bc/C/rpc',
      // 'https://avalanche.blockpi.network/v1/rpc/public',
      // 'https://1rpc.io/avax/c',
      // 'https://avalancheapi.terminet.io/ext/bc/C/rpc',
      // 'https://blastapi.io/public-api/avalanche',
    ]
  },
  {
    id: chains.blast.id,
    rpcs: [
      // 'https://blast.din.dev/rpc',
      "https://blast.gasswap.org",
      "https://blast.blockpi.network/v1/rpc/public",
      "https://rpc.blast.io",
      "https://blastl2-mainnet.public.blastapi.io",
      "https://rpc.ankr.com/blast"
    ]
  },
  {
    id: chains.sepolia.id,
    rpcs: [
      // 'https://gateway.tenderly.co/public/sepolia',
      // 'https://sepolia.gateway.tenderly.co',
      "https://rpc.sepolia.ethpandaops.io",
      "https://eth-sepolia-public.unifra.io",
      "https://endpoints.omniatech.io/v1/eth/sepolia/public",
      "https://ethereum-sepolia.publicnode.com",
      // 'https://ethereum-sepolia.blockpi.network/v1/rpc/public',
      "https://eth-sepolia.public.blastapi.io",
      "https://rpc.notadegen.com/eth/sepolia",
      "https://eth-sepolia.api.onfinality.io/public",
      "https://rpc-sepolia.rockx.com",
      "https://rpc.sepolia.org",
      "https://rpc2.sepolia.org"
      // 'https://sphinx.shardeum.org',
      // 'https://1rpc.io/sepolia',
      // 'https://api.zan.top/node/v1/eth/sepolia/public',
      // 'https://dapps.shardeum.org',
      // 'https://eth-sepolia.g.alchemy.com/v2/demo',
    ]
  }
];
function customTransport(params) {
  const { rpc, fetchOptions } = params;
  return viem.http(rpc, {
    key: rpc,
    name: rpc,
    fetchOptions,
    retryCount: 0,
    timeout: 4e3
  });
}
function chainRPCFallbacks(chain, fetchOptions = {
  cache: "no-store"
}) {
  return RPCS.find((c) => c.id === chain.id)?.rpcs.map(
    (rpc) => customTransport({
      rpc,
      fetchOptions
    })
  ) || [viem.http()];
}
const DEFAULT_RANK_OPTIONS = {
  retryCount: 0,
  rank: {
    interval: 1e5,
    sampleCount: 5,
    timeout: 4e3,
    weights: {
      latency: 0.3,
      stability: 0.7
    }
  }
};

const BOND_ERROR_MESSAGES = {
  AddressEmptyCode: {
    message: "The address field cannot be empty. Please provide a valid address.",
    reportToBugsnag: true
  },
  AddressInsufficientBalance: {
    message: "The address does not have enough balance to proceed with the transaction.",
    reportToBugsnag: false
  },
  ERC1167FailedCreateClone: {
    message: "Failed to create a clone due to an ERC1167 cloning error. Please check the implementation.",
    reportToBugsnag: true
  },
  FailedInnerCall: {
    message: "An internal call within the contract failed, indicating a potential issue with contract logic or state.",
    reportToBugsnag: true
  },
  MCV2_Bond__CreationFeeTransactionFailed: {
    message: "The transaction for the creation fee has failed. Ensure you have enough funds and the fee is correctly set.",
    reportToBugsnag: true
  },
  MCV2_Bond__ExceedMaxSupply: {
    message: "The creation of this token would exceed its maximum supply limit. No further tokens can be created.",
    reportToBugsnag: false
  },
  MCV2_Bond__ExceedTotalSupply: {
    message: "Attempting to exceed the total supply of tokens. Please verify the token amount.",
    reportToBugsnag: false
  },
  MCV2_Bond__InvalidConstructorParams: {
    message: "The constructor parameters provided are invalid. Please check and try again.",
    reportToBugsnag: true
  },
  MCV2_Bond__InvalidCreationFee: {
    message: "The creation fee provided is invalid. Ensure the fee meets the required criteria.",
    reportToBugsnag: true
  },
  MCV2_Bond__InvalidCreatorAddress: {
    message: "The creator address is invalid. A valid creator address is required to proceed.",
    reportToBugsnag: true
  },
  MCV2_Bond__InvalidCurrentSupply: {
    message: "The current supply value is invalid. Please check the supply amount and try again.",
    reportToBugsnag: true
  },
  MCV2_BOND__InvalidPaginationParameters: {
    message: "Pagination parameters are invalid. Please adjust your request and try again.",
    reportToBugsnag: false
  },
  MCV2_Bond__InvalidReceiver: {
    message: "The receiver address is invalid. Transactions require a valid receiver address.",
    reportToBugsnag: true
  },
  MCV2_Bond__InvalidReserveToken: {
    message: "The reserve token specified is invalid. Check the token address and try again.",
    reportToBugsnag: true
  },
  MCV2_Bond__InvalidStepParams: {
    message: "The step parameters provided are invalid. Please review and correct them.",
    reportToBugsnag: true
  },
  MCV2_Bond__InvalidTokenAmount: {
    message: "The token amount specified is invalid. Ensure the amount is correct and try again.",
    reportToBugsnag: true
  },
  MCV2_Bond__InvalidTokenCreationParams: {
    message: "The token creation parameters are invalid. Check the documentation and try again.",
    reportToBugsnag: true
  },
  MCV2_Bond__PermissionDenied: {
    message: "You do not have permission to perform this action. Ensure you have the necessary rights.",
    reportToBugsnag: true
  },
  MCV2_Bond__SlippageLimitExceeded: {
    message: "The slippage limit has been exceeded. Adjust your slippage settings and try again.",
    reportToBugsnag: false
  },
  MCV2_Bond__TokenNotFound: {
    message: "The specified token could not be found. Check the token address and try again.",
    reportToBugsnag: true
  },
  MCV2_Bond__TokenSymbolAlreadyExists: {
    message: "The token symbol already exists. Use a unique symbol and try again.",
    reportToBugsnag: true
  },
  MCV2_Royalty__InvalidParams: {
    message: "The parameters provided for royalty settings are invalid. Please review and correct them.",
    reportToBugsnag: true
  },
  MCV2_Royalty__NothingToClaim: {
    message: "There is nothing to claim at this time. Check back later or verify your entitlement.",
    reportToBugsnag: false
  },
  OwnableInvalidOwner: {
    message: "The operation was attempted by an invalid owner. Only the contract owner can perform this action.",
    reportToBugsnag: true
  },
  OwnableUnauthorizedAccount: {
    message: "The account is unauthorized. This action is restricted to authorized accounts only.",
    reportToBugsnag: true
  },
  SafeCastOverflowedUintDowncast: {
    message: "Overflow encountered during uint downcasting. Please check the values being cast.",
    reportToBugsnag: true
  },
  SafeERC20FailedOperation: {
    message: "An operation with ERC20 tokens failed. Ensure the contract and token addresses are correct.",
    reportToBugsnag: true
  }
};
const ERC20_ERROR_MESSAGES = {
  ERC20InsufficientAllowance: {
    message: "Your allowance for spending these tokens is insufficient. Please approve more tokens before proceeding.",
    reportToBugsnag: true
  },
  ERC20InsufficientBalance: {
    message: "Your balance is insufficient to complete this transaction. Please ensure you have enough tokens.",
    reportToBugsnag: false
  },
  ERC20InvalidApprover: {
    message: "The approver address is invalid or does not have permission to approve these tokens.",
    reportToBugsnag: true
  },
  ERC20InvalidReceiver: {
    message: "The receiver address is invalid. Please provide a valid address to complete the transaction.",
    reportToBugsnag: true
  },
  ERC20InvalidSender: {
    message: "The sender address is invalid or does not have permission to send these tokens.",
    reportToBugsnag: true
  },
  ERC20InvalidSpender: {
    message: "The spender address is invalid or not allowed to spend tokens on behalf of the sender.",
    reportToBugsnag: true
  },
  MCV2_Token__AlreadyInitialized: {
    message: "This token has already been initialized. Token initialization can only occur once.",
    reportToBugsnag: true
  },
  MCV2_Token__PermissionDenied: {
    message: "Permission denied. You do not have the necessary permissions to perform this action.",
    reportToBugsnag: true
  }
};
const ERC1155_ERROR_MESSAGES = {
  ERC1155InsufficientBalance: {
    message: "Your balance for one or more tokens is insufficient to complete this transaction.",
    reportToBugsnag: false
  },
  ERC1155InvalidApprover: {
    message: "The approver for this operation is invalid or does not have approval rights.",
    reportToBugsnag: true
  },
  ERC1155InvalidArrayLength: {
    message: "The length of the array provided does not match the expected length for this operation.",
    reportToBugsnag: true
  },
  ERC1155InvalidOperator: {
    message: "The operator address provided is invalid or not authorized to perform this operation.",
    reportToBugsnag: true
  },
  ERC1155InvalidReceiver: {
    message: "The receiver address provided is invalid. A valid address is required to receive the tokens.",
    reportToBugsnag: true
  },
  ERC1155InvalidSender: {
    message: "The sender address is invalid or unauthorized to send these tokens.",
    reportToBugsnag: true
  },
  ERC1155MissingApprovalForAll: {
    message: "Approval for all tokens has not been given. Please approve all tokens before proceeding.",
    reportToBugsnag: true
  },
  MCV2_MultiToken__AlreadyInitialized: {
    message: "The multi-token contract has already been initialized and cannot be initialized again.",
    reportToBugsnag: true
  },
  MCV2_MultiToken__BurnAmountExceedsTotalSupply: {
    message: "The amount to be burned exceeds the total supply of the token.",
    reportToBugsnag: true
  },
  MCV2_MultiToken__NotApproved: {
    message: "The operation was not approved. Ensure you have the necessary approvals before retrying.",
    reportToBugsnag: true
  },
  MCV2_MultiToken__PermissionDenied: {
    message: "Permission denied for this operation. Required permissions are not met.",
    reportToBugsnag: true
  }
};
const LOCKER_ERROR_MESSAGES = {
  AddressEmptyCode: {
    message: "The provided address is empty. Please ensure you input a valid address.",
    reportToBugsnag: true
  },
  AddressInsufficientBalance: {
    message: "The address has an insufficient balance for this operation. Please check your balance and try again.",
    reportToBugsnag: false
  },
  FailedInnerCall: {
    message: "An internal contract call failed. Please review the contract logic or contact support.",
    reportToBugsnag: true
  },
  LockUp__AlreadyClaimed: {
    message: "The rewards or tokens have already been claimed. You cannot claim them again.",
    reportToBugsnag: true
  },
  LockUp__InvalidPaginationParameters: {
    message: "Pagination parameters provided are invalid. Please adjust and retry your request.",
    reportToBugsnag: true
  },
  LockUp__InvalidParams: {
    message: "Parameters provided for the operation are invalid. Please review and correct them.",
    reportToBugsnag: true
  },
  LockUp__NotYetUnlocked: {
    message: "The locked tokens are not yet available for claim. Please wait until the unlock period has passed.",
    reportToBugsnag: true
  },
  LockUp__PermissionDenied: {
    message: "You do not have permission to perform this action. Check your account permissions and try again.",
    reportToBugsnag: true
  },
  SafeERC20FailedOperation: {
    message: "An operation with ERC20 tokens failed. Ensure the contract addresses and token details are correct.",
    reportToBugsnag: true
  }
};
const MERKLE_ERROR_MESSAGES = {
  AddressEmptyCode: {
    message: "The address provided is empty. A valid address is required for this operation.",
    reportToBugsnag: true
  },
  AddressInsufficientBalance: {
    message: "Insufficient balance for the operation. Please ensure your balance is sufficient to proceed.",
    reportToBugsnag: false
  },
  FailedInnerCall: {
    message: "An internal call within the contract failed, indicating a potential issue. Please investigate further.",
    reportToBugsnag: true
  },
  MerkleDistributor__AlreadyClaimed: {
    message: "The claim has already been made. Duplicate claims are not allowed.",
    reportToBugsnag: true
  },
  MerkleDistributor__AlreadyRefunded: {
    message: "The refund has already been processed. Duplicate refunds are not permitted.",
    reportToBugsnag: true
  },
  MerkleDistributor__Finished: {
    message: "The distribution period has ended. No further claims can be processed.",
    reportToBugsnag: true
  },
  MerkleDistributor__InvalidCaller: {
    message: "The caller is not authorized for this operation. Please check the caller\u2019s permissions.",
    reportToBugsnag: true
  },
  MerkleDistributor__InvalidPaginationParameters: {
    message: "Provided pagination parameters are invalid. Please correct them and try again.",
    reportToBugsnag: true
  },
  MerkleDistributor__InvalidParams: {
    message: "The parameters provided are invalid. Check the input parameters and retry.",
    reportToBugsnag: true
  },
  MerkleDistributor__InvalidProof: {
    message: "The provided proof is invalid. Ensure you connected the correct address for your airdrop claim.",
    reportToBugsnag: true
  },
  MerkleDistributor__NoClaimableTokensLeft: {
    message: "There are no tokens left to claim. All tokens have been distributed.",
    reportToBugsnag: true
  },
  MerkleDistributor__NothingToRefund: {
    message: "There is nothing to refund. Please check your claim status.",
    reportToBugsnag: true
  },
  MerkleDistributor__NotStarted: {
    message: "The distribution has not started yet. Please wait for the distribution period to begin.",
    reportToBugsnag: true
  },
  MerkleDistributor__PermissionDenied: {
    message: "Permission denied for this action. You do not have the necessary permissions.",
    reportToBugsnag: true
  },
  MerkleDistributor__Refunded: {
    message: "Your tokens have been refunded. Check your account for the refunded tokens.",
    reportToBugsnag: true
  },
  SafeERC20FailedOperation: {
    message: "An ERC20 operation failed. Ensure the contract address and token details are correct and try again.",
    reportToBugsnag: true
  }
};
const ZAP_ERROR_MESSAGES = {
  AddressEmptyCode: {
    message: "The provided address is empty. A valid address must be used for this operation.",
    reportToBugsnag: true
  },
  AddressInsufficientBalance: {
    message: "The address has insufficient balance for the intended operation. Please check your balance.",
    reportToBugsnag: false
  },
  FailedInnerCall: {
    message: "An internal call failed. This may indicate an issue with contract interactions or logic.",
    reportToBugsnag: true
  },
  MCV2_ZapV1__EthTransferFailed: {
    message: "ETH transfer failed. Ensure you have enough ETH and the recipient address is correct.",
    reportToBugsnag: true
  },
  MCV2_ZapV1__InvalidReceiver: {
    message: "The receiver address is invalid. Transactions require a valid receiver address.",
    reportToBugsnag: true
  },
  MCV2_ZapV1__ReserveIsNotWETH: {
    message: "The reserve is not WETH. This operation requires WETH as the reserve currency.",
    reportToBugsnag: true
  },
  MCV2_ZapV1__SlippageLimitExceeded: {
    message: "The slippage limit was exceeded. Adjust your slippage tolerance and try again.",
    reportToBugsnag: false
  },
  OwnableInvalidOwner: {
    message: "The action was attempted by an invalid owner. Only the contract owner can perform this action.",
    reportToBugsnag: true
  },
  OwnableUnauthorizedAccount: {
    message: "This account is unauthorized to perform the requested action. Check account permissions.",
    reportToBugsnag: true
  },
  SafeERC20FailedOperation: {
    message: "An operation involving ERC20 tokens failed. Check the contract and token details before retrying.",
    reportToBugsnag: true
  }
};
const CONTRACT_ERROR_MESSAGES = {
  ...BOND_ERROR_MESSAGES,
  ...ERC20_ERROR_MESSAGES,
  ...ERC1155_ERROR_MESSAGES,
  ...LOCKER_ERROR_MESSAGES,
  ...MERKLE_ERROR_MESSAGES,
  ...ZAP_ERROR_MESSAGES
};

const ARBITRUM_TOKENS = {
  "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1": {
    name: "Wrapped Ether",
    symbol: "WETH",
    address: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  },
  "0x912CE59144191C1204E64559FE8253a0e49E6548": {
    name: "Arbitrum",
    symbol: "ARB",
    address: "0x912CE59144191C1204E64559FE8253a0e49E6548",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/arbitrum.png",
      large: "https://mint.club/assets/tokens/large/arbitrum.png"
    }
  },
  "0xaf88d065e77c8cC2239327C5EDb3A432268e5831": {
    name: "USD Coin",
    symbol: "USDC",
    address: "0xaf88d065e77c8cC2239327C5EDb3A432268e5831",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8": {
    name: "Bridged USDC",
    symbol: "USDC.e",
    address: "0xFF970A61A04b1cA14834A43f5dE4533eBDDB5CC8",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a": {
    name: "GMX Token",
    symbol: "GMX",
    address: "0xfc5A1A6EB076a2C7aD06eD22C90d7E710E35ad0a",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/18323/small/arbit.png",
      large: "https://assets.coingecko.com/coins/images/18323/large/arbit.png"
    }
  },
  "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9": {
    name: "Tether USD",
    symbol: "USDT",
    address: "0xFd086bC7CD5C481DCC9C85ebE478A1C0b69FCbb9",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdt.png",
      large: "https://mint.club/assets/tokens/large/usdt.png"
    }
  },
  "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f": {
    name: "Wrapped BTC",
    symbol: "WBTC",
    address: "0x2f2a2543B76A4166549F7aaB2e75Bef0aefC5B0f",
    decimals: 8,
    image: {
      small: "https://mint.club/assets/tokens/small/wbtc.png",
      large: "https://mint.club/assets/tokens/large/wbtc.png"
    }
  },
  "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1": {
    name: "Dai Stablecoin",
    symbol: "DAI",
    address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/dai.png",
      large: "https://mint.club/assets/tokens/large/dai.png"
    }
  },
  "0xf97f4df75117a78c1A5a0DBb814Af92458539FB4": {
    name: "ChainLink Token",
    symbol: "LINK",
    address: "0xf97f4df75117a78c1A5a0DBb814Af92458539FB4",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/link.png",
      large: "https://mint.club/assets/tokens/large/link.png"
    }
  },
  "0x00CBcF7B3d37844e44b888Bc747bDd75FCf4E555": {
    name: "xPet.tech XPET",
    symbol: "XPET",
    address: "0x00CBcF7B3d37844e44b888Bc747bDd75FCf4E555",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/33553/small/xpet_token.jpeg",
      large: "https://assets.coingecko.com/coins/images/33553/large/xpet_token.jpeg"
    }
  },
  "0x5979D7b546E38E414F7E9822514be443A4800529": {
    name: "Wrapped stETH",
    symbol: "wstETH",
    address: "0x5979D7b546E38E414F7E9822514be443A4800529",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/18834/small/wstETH.png",
      large: "https://assets.coingecko.com/coins/images/18834/large/wstETH.png"
    }
  },
  "0x6fD58f5a2F3468e35fEb098b5F59F04157002407": {
    name: "poor guy",
    symbol: "pogai",
    address: "0x6fD58f5a2F3468e35fEb098b5F59F04157002407",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/30116/small/pogai.jpeg",
      large: "https://assets.coingecko.com/coins/images/30116/large/pogai.jpeg"
    }
  },
  "0x0c880f6761F1af8d9Aa9C466984b80DAb9a8c9e8": {
    name: "Pendle",
    symbol: "PENDLE",
    address: "0x0c880f6761F1af8d9Aa9C466984b80DAb9a8c9e8",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/15069/small/Pendle_Logo_Normal-03.png",
      large: "https://assets.coingecko.com/coins/images/15069/large/Pendle_Logo_Normal-03.png"
    }
  },
  "0x539bdE0d7Dbd336b79148AA742883198BBF60342": {
    name: "Magic",
    symbol: "MAGIC",
    address: "0x539bdE0d7Dbd336b79148AA742883198BBF60342",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/18623/small/magic.png",
      large: "https://assets.coingecko.com/coins/images/18623/large/magic.png"
    }
  },
  "0x6dAF586B7370B14163171544fca24AbcC0862ac5": {
    name: "xPet.tech BPET",
    symbol: "BPET",
    address: "0x6dAF586B7370B14163171544fca24AbcC0862ac5",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/33848/small/BPET_logo.png",
      large: "https://assets.coingecko.com/coins/images/33848/large/BPET_logo.png"
    }
  },
  "0x4e352cF164E64ADCBad318C3a1e222E9EBa4Ce42": {
    name: "MUX Protocol",
    symbol: "MCB",
    address: "0x4e352cF164E64ADCBad318C3a1e222E9EBa4Ce42",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/11796/small/mux.jpg",
      large: "https://assets.coingecko.com/coins/images/11796/large/mux.jpg"
    }
  },
  "0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F": {
    name: "Frax",
    symbol: "FRAX",
    address: "0x17FC002b466eEc40DaE837Fc4bE5c67993ddBd6F",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/frax.png",
      large: "https://mint.club/assets/tokens/large/frax.png"
    }
  },
  "0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0": {
    name: "Uniswap",
    symbol: "UNI",
    address: "0xFa7F8980b0f1E64A2062791cc3b0871572f1F7f0",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/uni.png",
      large: "https://mint.club/assets/tokens/large/uni.png"
    }
  },
  "0x13Ad51ed4F1B7e9Dc168d8a00cB3f4dDD85EfA60": {
    name: "Lido DAO",
    symbol: "LDO",
    address: "0x13Ad51ed4F1B7e9Dc168d8a00cB3f4dDD85EfA60",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ldo.png",
      large: "https://mint.club/assets/tokens/large/ldo.png"
    }
  },
  "0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978": {
    name: "Curve DAO Token",
    symbol: "CRV",
    address: "0x11cDb42B0EB46D95f990BeDD4695A6e3fA034978",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/curve.png",
      large: "https://mint.club/assets/tokens/large/curve.png"
    }
  }
};

const AVALANCHE_TOKENS = {
  "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7": {
    name: "Wrapped AVAX",
    symbol: "WAVAX",
    address: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/avalanche.png",
      large: "https://mint.club/assets/tokens/large/avalanche.png"
    }
  },
  "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E": {
    name: "USD Coin",
    symbol: "USDC",
    address: "0xB97EF9Ef8734C71904D8002F8b6Bc66Dd9c48a6E",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7": {
    name: "TetherToken",
    symbol: "USDt",
    address: "0x9702230A8Ea53601f5cD2dc00fDBc13d4dF4A8c7",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdt.png",
      large: "https://mint.club/assets/tokens/large/usdt.png"
    }
  },
  "0x152b9d0FdC40C096757F570A51E494bd4b943E50": {
    name: "Bitcoin",
    symbol: "BTC.b",
    address: "0x152b9d0FdC40C096757F570A51E494bd4b943E50",
    decimals: 8,
    image: {
      small: "https://assets.coingecko.com/coins/images/26115/small/btcb.png",
      large: "https://assets.coingecko.com/coins/images/26115/large/btcb.png"
    }
  },
  "0x2F6F07CDcf3588944Bf4C42aC74ff24bF56e7590": {
    name: "StargateToken",
    symbol: "STG",
    address: "0x2F6F07CDcf3588944Bf4C42aC74ff24bF56e7590",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/24413/small/STG_LOGO.png",
      large: "https://assets.coingecko.com/coins/images/24413/large/STG_LOGO.png"
    }
  },
  "0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd": {
    name: "JoeToken",
    symbol: "JOE",
    address: "0x6e84a6216eA6dACC71eE8E6b0a5B7322EEbC0fDd",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/17569/small/JoeToken.png",
      large: "https://assets.coingecko.com/coins/images/17569/large/JoeToken.png"
    }
  },
  "0x714f020C54cc9D104B6F4f6998C63ce2a31D1888": {
    name: "Step App",
    symbol: "FITFI",
    address: "0x714f020C54cc9D104B6F4f6998C63ce2a31D1888",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/25015/small/200x200.png",
      large: "https://assets.coingecko.com/coins/images/25015/large/200x200.png"
    }
  }
};

const AVALANCHE_FUJI_TOKENS = {
  "0xd00ae08403B9bbb9124bB305C09058E32C39A48c": {
    name: "Wrapped AVAX",
    symbol: "WAVAX",
    address: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/avalanche.png",
      large: "https://mint.club/assets/tokens/large/avalanche.png"
    }
  }
};

const BASE_TOKENS = {
  "0x4200000000000000000000000000000000000006": {
    name: "Wrapped Ether",
    symbol: "WETH",
    address: "0x4200000000000000000000000000000000000006",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  },
  "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913": {
    name: "USDC",
    symbol: "USDC",
    address: "0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA": {
    name: "Bridged USDC",
    symbol: "USDBC",
    address: "0xd9aAEc86B65D86f6A7B5B1b0c42FFA531710b6CA",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb": {
    name: "Dai",
    symbol: "DAI",
    address: "0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/dai.png",
      large: "https://mint.club/assets/tokens/large/dai.png"
    }
  },
  "0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22": {
    name: "Coinbase Wrapped Staked ETH",
    symbol: "CBETH",
    address: "0x2Ae3F1Ec7F1F5012CFEab0185bfc7aa3cf0DEc22",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/27008/small/cbeth.png",
      large: "https://assets.coingecko.com/coins/images/27008/large/cbeth.png"
    }
  },
  "0x940181a94A35A4569E4529A3CDfB74e38FD98631": {
    name: "Aerodrome Finance",
    symbol: "AERO",
    address: "0x940181a94A35A4569E4529A3CDfB74e38FD98631",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/31745/small/token.png",
      large: "https://assets.coingecko.com/coins/images/31745/large/token.png"
    }
  },
  "0x27D2DECb4bFC9C76F0309b8E88dec3a601Fe25a8": {
    name: "Bald",
    symbol: "BALD",
    address: "0x27D2DECb4bFC9C76F0309b8E88dec3a601Fe25a8",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/31119/small/cdjxKSjo_400x400.jpg",
      large: "https://assets.coingecko.com/coins/images/31119/large/cdjxKSjo_400x400.jpg"
    }
  },
  "0xfA980cEd6895AC314E7dE34Ef1bFAE90a5AdD21b": {
    name: "Echelon Prime",
    symbol: "PRIME",
    address: "0xfA980cEd6895AC314E7dE34Ef1bFAE90a5AdD21b",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/29053/small/prime-logo-small-border_%282%29.png",
      large: "https://assets.coingecko.com/coins/images/29053/large/prime-logo-small-border_%282%29.png"
    }
  },
  "0x236aa50979D5f3De3Bd1Eeb40E81137F22ab794b": {
    name: "tBTC",
    symbol: "TBTC",
    address: "0x236aa50979D5f3De3Bd1Eeb40E81137F22ab794b",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/11224/small/0x18084fba666a33d37592fa2633fd49a74dd93a88.png",
      large: "https://assets.coingecko.com/coins/images/11224/large/0x18084fba666a33d37592fa2633fd49a74dd93a88.png"
    }
  },
  "0x4158734D47Fc9692176B5085E0F52ee0Da5d47F1": {
    name: "Balancer",
    symbol: "BAL",
    address: "0x4158734D47Fc9692176B5085E0F52ee0Da5d47F1",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/11683/small/Balancer.png",
      large: "https://assets.coingecko.com/coins/images/11683/large/Balancer.png"
    }
  },
  "0xdCf5130274753c8050aB061B1a1DCbf583f5bFd0": {
    name: "ViciCoin",
    symbol: "VCNT",
    address: "0xdCf5130274753c8050aB061B1a1DCbf583f5bFd0",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/31305/small/ViciCoin_-_small.png",
      large: "https://assets.coingecko.com/coins/images/31305/large/ViciCoin_-_small.png"
    }
  },
  "0xCfA3Ef56d303AE4fAabA0592388F19d7C3399FB4": {
    name: "Electronic USD",
    symbol: "EUSD",
    address: "0xCfA3Ef56d303AE4fAabA0592388F19d7C3399FB4",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/28445/small/0xa0d69e286b938e21cbf7e51d71f6a4c8918f482f.png",
      large: "https://assets.coingecko.com/coins/images/28445/large/0xa0d69e286b938e21cbf7e51d71f6a4c8918f482f.png"
    }
  },
  "0x1C7a460413dD4e964f96D8dFC56E7223cE88CD85": {
    name: "Seamless",
    symbol: "SEAM",
    address: "0x1C7a460413dD4e964f96D8dFC56E7223cE88CD85",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/33480/small/Seamless_Logo_Black_Transparent.png",
      large: "https://assets.coingecko.com/coins/images/33480/large/Seamless_Logo_Black_Transparent.png"
    }
  },
  "0x78a087d713Be963Bf307b18F2Ff8122EF9A63ae9": {
    name: "BaseSwap",
    symbol: "BSWAP",
    address: "0x78a087d713Be963Bf307b18F2Ff8122EF9A63ae9",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/31245/small/Baseswap_LogoNew.jpg",
      large: "https://assets.coingecko.com/coins/images/31245/large/Baseswap_LogoNew.jpg"
    }
  }
};

const BLAST_TOKENS = {
  "0x4300000000000000000000000000000000000004": {
    name: "Wrapped Ether",
    symbol: "WETH",
    address: "0x4300000000000000000000000000000000000004",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  },
  "0x4300000000000000000000000000000000000003": {
    name: "USDBlast",
    symbol: "USDB",
    address: "0x4300000000000000000000000000000000000003",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/blast.png",
      large: "https://mint.club/assets/tokens/large/blast.png"
    }
  }
};

const BLAST_SEPOLIA_TOKENS = {
  "0x4200000000000000000000000000000000000023": {
    name: "Wrapped Ether",
    symbol: "WETH",
    address: "0x4200000000000000000000000000000000000023",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  },
  "0x4200000000000000000000000000000000000022": {
    name: "USDBlast",
    symbol: "USDB",
    address: "0x4200000000000000000000000000000000000022",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/blast.png",
      large: "https://mint.club/assets/tokens/large/blast.png"
    }
  }
};

const BSC_TOKENS = {
  "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c": {
    name: "Wrapped BNB",
    symbol: "WBNB",
    address: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/825/small/bnb-icon2_2x.png",
      large: "https://assets.coingecko.com/coins/images/825/large/bnb-icon2_2x.png"
    }
  },
  "0x1f3Af095CDa17d63cad238358837321e95FC5915": {
    name: "Mint.club",
    symbol: "MINT",
    address: "0x1f3Af095CDa17d63cad238358837321e95FC5915",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/mint.png",
      large: "https://mint.club/assets/tokens/large/mint.png"
    }
  },
  "0x55d398326f99059ff775485246999027b3197955": {
    name: "Binance-Peg BSC-USD",
    symbol: "BSC-USD",
    address: "0x55d398326f99059ff775485246999027b3197955",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/usdt.png",
      large: "https://mint.club/assets/tokens/large/usdt.png"
    }
  },
  "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82": {
    name: "PancakeSwap Token",
    symbol: "Cake",
    address: "0x0E09FaBB73Bd3Ade0a17ECC321fD13a19e81cE82",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/12632/small/pancakeswap-cake-logo_%281%29.png",
      large: "https://assets.coingecko.com/coins/images/12632/large/pancakeswap-cake-logo_%281%29.png"
    }
  },
  "0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63": {
    name: "Venus",
    symbol: "XVS",
    address: "0xcF6BB5389c92Bdda8a3747Ddb454cB7a64626C63",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/12677/small/download.jpg",
      large: "https://assets.coingecko.com/coins/images/12677/large/download.jpg"
    }
  },
  "0x965F527D9159dCe6288a2219DB51fc6Eef120dD1": {
    name: "Biswap",
    symbol: "BSW",
    address: "0x965F527D9159dCe6288a2219DB51fc6Eef120dD1",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/16845/small/biswap.png",
      large: "https://assets.coingecko.com/coins/images/16845/large/biswap.png"
    }
  },
  "0x2170Ed0880ac9A755fd29B2688956BD959F933F8": {
    name: "Binance-Peg Ethereum Token",
    symbol: "ETH",
    address: "0x2170Ed0880ac9A755fd29B2688956BD959F933F8",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  },
  "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d": {
    name: "Binance-Peg USD Coin",
    symbol: "USDC",
    address: "0x8AC76a51cc950d9822D68b83fE1Ad97B32Cd580d",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3": {
    name: "Binance-Peg Dai Token",
    symbol: "DAI",
    address: "0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/dai.png",
      large: "https://mint.club/assets/tokens/large/dai.png"
    }
  },
  "0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c": {
    name: "Binance-Peg BTCB Token",
    symbol: "BTCB",
    address: "0x7130d2A12B9BCbFAe4f2634d864A1Ee1Ce3Ead9c",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/wbtc.png",
      large: "https://mint.club/assets/tokens/large/wbtc.png"
    }
  },
  "0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE": {
    name: "Binance-Peg XRP Token",
    symbol: "XRP",
    address: "0x1D2F0da169ceB9fC7B3144628dB156f3F6c60dBE",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/xrp.png",
      large: "https://mint.club/assets/tokens/large/xrp.png"
    }
  },
  "0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD": {
    name: "Binance-Peg ChainLink Token",
    symbol: "LINK",
    address: "0xF8A0BF9cF54Bb92F17374d9e9A321E6a111a51bD",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/link.png",
      large: "https://mint.club/assets/tokens/large/link.png"
    }
  },
  "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56": {
    name: "Binance-Peg BUSD Token",
    symbol: "BUSD",
    address: "0xe9e7CEA3DedcA5984780Bafc599bD69ADd087D56",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/busd.png",
      large: "https://mint.club/assets/tokens/large/busd.png"
    }
  },
  "0xd17479997F34dd9156Deef8F95A52D81D265be9c": {
    name: "Decentralized USD",
    symbol: "USDD",
    address: "0xd17479997F34dd9156Deef8F95A52D81D265be9c",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/usdd.png",
      large: "https://mint.club/assets/tokens/large/usdd.png"
    }
  },
  "0xCC42724C6683B7E57334c4E856f4c9965ED682bD": {
    name: "Matic Token",
    symbol: "MATIC",
    address: "0xCC42724C6683B7E57334c4E856f4c9965ED682bD",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/matic.png",
      large: "https://mint.club/assets/tokens/large/matic.png"
    }
  },
  "0x5f0Da599BB2ccCfcf6Fdfd7D81743B6020864350": {
    name: "Binance-Peg Maker",
    symbol: "MKR",
    address: "0x5f0Da599BB2ccCfcf6Fdfd7D81743B6020864350",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/mkr.png",
      large: "https://mint.club/assets/tokens/large/mkr.png"
    }
  },
  "0xBf5140A22578168FD562DCcF235E5D43A02ce9B1": {
    name: "Binance-Peg Uniswap",
    symbol: "UNI",
    address: "0xBf5140A22578168FD562DCcF235E5D43A02ce9B1",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/uni.png",
      large: "https://mint.club/assets/tokens/large/uni.png"
    }
  },
  "0x111111111117dC0aa78b770fA6A738034120C302": {
    name: "1INCH Token",
    symbol: "1INCH",
    address: "0x111111111117dC0aa78b770fA6A738034120C302",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/1inch.svg",
      large: "https://mint.club/assets/tokens/large/1inch.svg"
    }
  },
  "0x8595F9dA7b868b1822194fAEd312235E43007b49": {
    name: "Binance-Peg BitTorrent Token",
    symbol: "BTT",
    address: "0x8595F9dA7b868b1822194fAEd312235E43007b49",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/btt.png",
      large: "https://mint.club/assets/tokens/large/btt.png"
    }
  },
  "0x2859e4544C4bB03966803b044A93563Bd2D0DD4D": {
    name: "Binance-Peg Shiba Inu Token",
    symbol: "SHIB",
    address: "0x2859e4544C4bB03966803b044A93563Bd2D0DD4D",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/shib.png",
      large: "https://mint.club/assets/tokens/large/shib.png"
    }
  },
  "0xbA2aE424d960c26247Dd6c32edC70B295c744C43": {
    name: "Binance-Peg Dogecoin Token",
    symbol: "DOGE",
    address: "0xbA2aE424d960c26247Dd6c32edC70B295c744C43",
    decimals: 8,
    image: {
      small: "https://mint.club/assets/tokens/small/doge.png",
      large: "https://mint.club/assets/tokens/large/doge.png"
    }
  },
  "0xc748673057861a797275CD8A068AbB95A902e8de": {
    name: "Baby Doge Coin",
    symbol: "BabyDoge",
    address: "0xc748673057861a797275CD8A068AbB95A902e8de",
    decimals: 9,
    image: {
      small: "https://mint.club/assets/tokens/small/babydoge.png",
      large: "https://mint.club/assets/tokens/large/babydoge.png"
    }
  },
  "0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47": {
    name: "Binance-Peg Cardano Token",
    symbol: "ADA",
    address: "0x3EE2200Efb3400fAbB9AacF31297cBdD1d435D47",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/cardano.png",
      large: "https://mint.club/assets/tokens/large/cardano.png"
    }
  },
  "0xCE7de646e7208a4Ef112cb6ed5038FA6cC6b12e3": {
    name: "TRON",
    symbol: "TRX",
    address: "0xCE7de646e7208a4Ef112cb6ed5038FA6cC6b12e3",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/tron.png",
      large: "https://mint.club/assets/tokens/large/tron.png"
    }
  },
  "0x4338665CBB7B2485A8855A139b75D5e34AB0DB94": {
    name: "Binance-Peg Litecoin Token",
    symbol: "LTC",
    address: "0x4338665CBB7B2485A8855A139b75D5e34AB0DB94",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ltc.png",
      large: "https://mint.club/assets/tokens/large/ltc.png"
    }
  },
  "0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402": {
    name: "Binance-Peg Polkadot Token",
    symbol: "DOT",
    address: "0x7083609fCE4d1d8Dc0C979AAb8c869Ea2C873402",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/dot.png",
      large: "https://mint.club/assets/tokens/large/dot.png"
    }
  }
};

const MAINNET_TOKENS = {
  "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2": {
    name: "Wrapped Ether",
    symbol: "WETH",
    address: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  },
  "0x9AAb071B4129B083B01cB5A0Cb513Ce7ecA26fa5": {
    name: "Hunt Token",
    symbol: "HUNT",
    address: "0x9AAb071B4129B083B01cB5A0Cb513Ce7ecA26fa5",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/hunt.png",
      large: "https://mint.club/assets/tokens/large/hunt.png"
    }
  },
  "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48": {
    name: "USD Coin",
    symbol: "USDC",
    address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0xdAC17F958D2ee523a2206206994597C13D831ec7": {
    name: "Tether USD",
    symbol: "USDT",
    address: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdt.png",
      large: "https://mint.club/assets/tokens/large/usdt.png"
    }
  },
  "0x6B175474E89094C44Da98b954EedeAC495271d0F": {
    name: "Dai Stablecoin",
    symbol: "DAI",
    address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/dai.png",
      large: "https://mint.club/assets/tokens/large/dai.png"
    }
  },
  "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599": {
    name: "Wrapped BTC",
    symbol: "WBTC",
    address: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
    decimals: 8,
    image: {
      small: "https://mint.club/assets/tokens/small/wbtc.png",
      large: "https://mint.club/assets/tokens/large/wbtc.png"
    }
  },
  "0x4d224452801ACEd8B2F0aebE155379bb5D594381": {
    name: "ApeCoin",
    symbol: "APE",
    address: "0x4d224452801ACEd8B2F0aebE155379bb5D594381",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ape.png",
      large: "https://mint.club/assets/tokens/large/ape.png"
    }
  },
  "0x6982508145454ce325ddbe47a25d4ec3d2311933": {
    name: "Pepe",
    symbol: "PEPE",
    address: "0x6982508145454ce325ddbe47a25d4ec3d2311933",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/pepe.webp",
      large: "https://mint.club/assets/tokens/large/pepe.webp"
    }
  },
  "0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE": {
    name: "Shiba Inu",
    symbol: "SHIB",
    address: "0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/shib.png",
      large: "https://mint.club/assets/tokens/large/shib.png"
    }
  },
  "0xb131f4A55907B10d1F0A50d8ab8FA09EC342cd74": {
    name: "Memecoin",
    symbol: "MEME",
    address: "0xb131f4A55907B10d1F0A50d8ab8FA09EC342cd74",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/32528/small/memecoin_%282%29.png",
      large: "https://assets.coingecko.com/coins/images/32528/large/memecoin_%282%29.png"
    }
  },
  "0x514910771AF9Ca656af840dff83E8264EcF986CA": {
    name: "ChainLink Token",
    symbol: "LINK",
    address: "0x514910771AF9Ca656af840dff83E8264EcF986CA",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/link.png",
      large: "https://mint.club/assets/tokens/large/link.png"
    }
  },
  "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0": {
    name: "Matic Token",
    symbol: "MATIC",
    address: "0x7D1AfA7B718fb893dB30A3aBc0Cfc608AaCfeBB0",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/matic.png",
      large: "https://mint.club/assets/tokens/large/matic.png"
    }
  },
  "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2": {
    name: "Maker",
    symbol: "MKR",
    address: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/mkr.png",
      large: "https://mint.club/assets/tokens/large/mkr.png"
    }
  },
  "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984": {
    name: "Uniswap",
    symbol: "UNI",
    address: "0x1f9840a85d5aF5bf1D1762F925BDADdC4201F984",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/uni.png",
      large: "https://mint.club/assets/tokens/large/uni.png"
    }
  },
  "0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32": {
    name: "Lido DAO Token",
    symbol: "LDO",
    address: "0x5A98FcBEA516Cf06857215779Fd812CA3beF1B32",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ldo.png",
      large: "https://mint.club/assets/tokens/large/ldo.png"
    }
  },
  "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0": {
    name: "Wrapped stETH",
    symbol: "wstETH",
    address: "0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/18834/small/wstETH.png",
      large: "https://assets.coingecko.com/coins/images/18834/large/wstETH.png"
    }
  },
  "0x111111111117dC0aa78b770fA6A738034120C302": {
    name: "1INCH Token",
    symbol: "1INCH",
    address: "0x111111111117dC0aa78b770fA6A738034120C302",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/1inch.svg",
      large: "https://mint.club/assets/tokens/large/1inch.svg"
    }
  },
  "0x6B3595068778DD592e39A122f4f5a5cF09C90fE2": {
    name: "SushiToken",
    symbol: "SUSHI",
    address: "0x6B3595068778DD592e39A122f4f5a5cF09C90fE2",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/12271/small/512x512_Logo_no_chop.png",
      large: "https://assets.coingecko.com/coins/images/12271/large/512x512_Logo_no_chop.png"
    }
  },
  "0x5283D291DBCF85356A21bA090E6db59121208b44": {
    name: "Blur",
    symbol: "BLUR",
    address: "0x5283D291DBCF85356A21bA090E6db59121208b44",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/28453/small/blur.png",
      large: "https://assets.coingecko.com/coins/images/28453/large/blur.png"
    }
  },
  "0xF57e7e7C23978C3cAEC3C3548E3D615c346e79fF": {
    name: "Immutable X",
    symbol: "IMX",
    address: "0xF57e7e7C23978C3cAEC3C3548E3D615c346e79fF",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/17233/small/immutableX-symbol-BLK-RGB.png",
      large: "https://assets.coingecko.com/coins/images/17233/large/immutableX-symbol-BLK-RGB.png"
    }
  },
  "0xf4d2888d29D722226FafA5d9B24F9164c092421E": {
    name: "LooksRare Token",
    symbol: "LOOKS",
    address: "0xf4d2888d29D722226FafA5d9B24F9164c092421E",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/looks.png",
      large: "https://mint.club/assets/tokens/large/looks.png"
    }
  },
  "0x6810e776880C02933D47DB1b9fc05908e5386b96": {
    name: "Gnosis Token",
    symbol: "GNO",
    address: "0x6810e776880C02933D47DB1b9fc05908e5386b96",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/gno.png",
      large: "https://mint.club/assets/tokens/large/gno.png"
    }
  },
  "0x1a7e4e63778B4f12a199C062f3eFdD288afCBce8": {
    name: "agEUR",
    symbol: "agEUR",
    address: "0x1a7e4e63778B4f12a199C062f3eFdD288afCBce8",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ageur.png",
      large: "https://mint.club/assets/tokens/large/ageur.png"
    }
  },
  "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9": {
    name: "Aave Token",
    symbol: "AAVE",
    address: "0x7Fc66500c84A76Ad7e9c93437bFc5Ac33E2DDaE9",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/aave.png",
      large: "https://mint.club/assets/tokens/large/aave.png"
    }
  }
};

const OPTIMISM_TOKENS = {
  "0x4200000000000000000000000000000000000006": {
    name: "Wrapped Ether",
    symbol: "WETH",
    address: "0x4200000000000000000000000000000000000006",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  },
  "0x4200000000000000000000000000000000000042": {
    name: "Optimism",
    symbol: "OP",
    address: "0x4200000000000000000000000000000000000042",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/optimism.png",
      large: "https://mint.club/assets/tokens/large/optimism.png"
    }
  },
  "0x7F5c764cBc14f9669B88837ca1490cCa17c31607": {
    name: "USD Coin",
    symbol: "USDC",
    address: "0x7F5c764cBc14f9669B88837ca1490cCa17c31607",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58": {
    name: "Tether USD",
    symbol: "USDT",
    address: "0x94b008aA00579c1307B0EF2c499aD98a8ce58e58",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdt.png",
      large: "https://mint.club/assets/tokens/large/usdt.png"
    }
  },
  "0x68f180fcCe6836688e9084f035309E29Bf0A2095": {
    name: "Wrapped BTC",
    symbol: "WBTC",
    address: "0x68f180fcCe6836688e9084f035309E29Bf0A2095",
    decimals: 8,
    image: {
      small: "https://mint.club/assets/tokens/small/wbtc.png",
      large: "https://mint.club/assets/tokens/large/wbtc.png"
    }
  },
  "0xdC6fF44d5d932Cbd77B52E5612Ba0529DC6226F1": {
    name: "Worldcoin",
    symbol: "WLD",
    address: "0xdC6fF44d5d932Cbd77B52E5612Ba0529DC6226F1",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/worldcoin.png",
      large: "https://mint.club/assets/tokens/large/worldcoin.png"
    }
  },
  "0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6": {
    name: "ChainLink Token",
    symbol: "LINK",
    address: "0x350a791Bfc2C21F9Ed5d10980Dad2e2638ffa7f6",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/link.png",
      large: "https://mint.club/assets/tokens/large/link.png"
    }
  },
  "0xFdb794692724153d1488CcdBE0C56c252596735F": {
    name: "Lido DAO Token",
    symbol: "LDO",
    address: "0xFdb794692724153d1488CcdBE0C56c252596735F",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ldo.png",
      large: "https://mint.club/assets/tokens/large/ldo.png"
    }
  },
  "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1": {
    name: "Dai Stablecoin",
    symbol: "DAI",
    address: "0xDA10009cBd5D07dd0CeCc66161FC93D7c9000da1",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/dai.png",
      large: "https://mint.club/assets/tokens/large/dai.png"
    }
  },
  "0x2E3D870790dC77A83DD1d18184Acc7439A53f475": {
    name: "Frax",
    symbol: "FRAX",
    address: "0x2E3D870790dC77A83DD1d18184Acc7439A53f475",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/frax.png",
      large: "https://mint.club/assets/tokens/large/frax.png"
    }
  },
  "0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9": {
    name: "Synth sUSD",
    symbol: "sUSD",
    address: "0x8c6f28f2F1A3C87F0f938b96d27520d9751ec8d9",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/sUSD.png",
      large: "https://mint.club/assets/tokens/large/sUSD.png"
    }
  },
  "0x9560e827aF36c94D2Ac33a39bCE1Fe78631088Db": {
    name: "VelodromeV2",
    symbol: "VELO",
    address: "0x9560e827aF36c94D2Ac33a39bCE1Fe78631088Db",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/velo.png",
      large: "https://mint.club/assets/tokens/large/velo.png"
    }
  },
  "0x76FB31fb4af56892A25e32cFC43De717950c9278": {
    name: "Aave Token",
    symbol: "AAVE",
    address: "0x76FB31fb4af56892A25e32cFC43De717950c9278",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/aave.png",
      large: "https://mint.club/assets/tokens/large/aave.png"
    }
  },
  "0x1F32b1c2345538c0c6f582fCB022739c4A194Ebb": {
    name: "Wrapped stETH",
    symbol: "wstETH",
    address: "0x1F32b1c2345538c0c6f582fCB022739c4A194Ebb",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/18834/small/wstETH.png",
      large: "https://assets.coingecko.com/coins/images/18834/large/wstETH.png"
    }
  },
  "0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4": {
    name: "Synthetix Network Token",
    symbol: "SNX",
    address: "0x8700dAec35aF8Ff88c16BdF0418774CB3D7599B4",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/3406/small/SNX.png",
      large: "https://assets.coingecko.com/coins/images/3406/large/SNX.png"
    }
  },
  "0x9e1028F5F1D5eDE59748FFceE5532509976840E0": {
    name: "Perpetual",
    symbol: "PERP",
    address: "0x9e1028F5F1D5eDE59748FFceE5532509976840E0",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/12381/small/60d18e06844a844ad75901a9_mark_only_03.png",
      large: "https://assets.coingecko.com/coins/images/12381/large/60d18e06844a844ad75901a9_mark_only_03.png"
    }
  },
  "0x9485aca5bbBE1667AD97c7fE7C4531a624C8b1ED": {
    name: "agEUR",
    symbol: "agEUR",
    address: "0x9485aca5bbBE1667AD97c7fE7C4531a624C8b1ED",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ageur.png",
      large: "https://mint.club/assets/tokens/large/ageur.png"
    }
  }
};

const POLYGON_TOKENS = {
  "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270": {
    name: "Wrapped Matic",
    symbol: "WMATIC",
    address: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/matic.png",
      large: "https://mint.club/assets/tokens/large/matic.png"
    }
  },
  "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619": {
    name: "Wrapped Ether",
    symbol: "WETH",
    address: "0x7ceB23fD6bC0adD59E62ac25578270cFf1b9f619",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  },
  "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174": {
    name: "USD Coin",
    symbol: "USDC",
    address: "0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdc.png",
      large: "https://mint.club/assets/tokens/large/usdc.png"
    }
  },
  "0xc2132D05D31c914a87C6611C10748AEb04B58e8F": {
    name: "Tether USD",
    symbol: "USDT",
    address: "0xc2132D05D31c914a87C6611C10748AEb04B58e8F",
    decimals: 6,
    image: {
      small: "https://mint.club/assets/tokens/small/usdt.png",
      large: "https://mint.club/assets/tokens/large/usdt.png"
    }
  },
  "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6": {
    name: "Wrapped BTC",
    symbol: "WBTC",
    address: "0x1BFD67037B42Cf73acF2047067bd4F2C47D9BfD6",
    decimals: 8,
    image: {
      small: "https://mint.club/assets/tokens/small/wbtc.png",
      large: "https://mint.club/assets/tokens/large/wbtc.png"
    }
  },
  "0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39": {
    name: "ChainLink Token",
    symbol: "LINK",
    address: "0x53E0bca35eC356BD5ddDFebbD1Fc0fD03FaBad39",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/link.png",
      large: "https://mint.club/assets/tokens/large/link.png"
    }
  },
  "0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89": {
    name: "Frax",
    symbol: "FRAX",
    address: "0x45c32fA6DF82ead1e2EF74d17b76547EDdFaFF89",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/frax.png",
      large: "https://mint.club/assets/tokens/large/frax.png"
    }
  },
  "0xb33EaAd8d922B1083446DC23f610c2567fB5180f": {
    name: "Uniswap",
    symbol: "UNI",
    address: "0xb33EaAd8d922B1083446DC23f610c2567fB5180f",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/uni.png",
      large: "https://mint.club/assets/tokens/large/uni.png"
    }
  },
  "0xC3C7d422809852031b44ab29EEC9F1EfF2A58756": {
    name: "Lido DAO Token",
    symbol: "LDO",
    address: "0xC3C7d422809852031b44ab29EEC9F1EfF2A58756",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ldo.png",
      large: "https://mint.club/assets/tokens/large/ldo.png"
    }
  },
  "0x9c2C5fd7b07E95EE044DDeba0E97a665F142394f": {
    name: "1INCH Token",
    symbol: "1INCH",
    address: "0x9c2C5fd7b07E95EE044DDeba0E97a665F142394f",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/1inch.svg",
      large: "https://mint.club/assets/tokens/large/1inch.svg"
    }
  },
  "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063": {
    name: "Dai Stablecoin",
    symbol: "DAI",
    address: "0x8f3Cf7ad23Cd3CaDbD9735AFf958023239c6A063",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/dai.png",
      large: "https://mint.club/assets/tokens/large/dai.png"
    }
  },
  "0xB7b31a6BC18e48888545CE79e83E06003bE70930": {
    name: "ApeCoin",
    symbol: "APE",
    address: "0xB7b31a6BC18e48888545CE79e83E06003bE70930",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ape.png",
      large: "https://mint.club/assets/tokens/large/ape.png"
    }
  },
  "0x6f8a06447Ff6FcF75d803135a7de15CE88C1d4ec": {
    name: "Shiba Inu",
    symbol: "SHIB",
    address: "0x6f8a06447Ff6FcF75d803135a7de15CE88C1d4ec",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/shib.png",
      large: "https://mint.club/assets/tokens/large/shib.png"
    }
  },
  "0xD6DF932A45C0f255f85145f286eA0b292B21C90B": {
    name: "Aave Token",
    symbol: "AAVE",
    address: "0xD6DF932A45C0f255f85145f286eA0b292B21C90B",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/aave.png",
      large: "https://mint.club/assets/tokens/large/aave.png"
    }
  },
  "0xBbba073C31bF03b8ACf7c28EF0738DeCF3695683": {
    name: "SAND",
    symbol: "SAND",
    address: "0xBbba073C31bF03b8ACf7c28EF0738DeCF3695683",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/sandbox.png",
      large: "https://mint.club/assets/tokens/large/sandbox.png"
    }
  },
  "0x172370d5Cd63279eFa6d502DAB29171933a610AF": {
    name: "Curve DAO Token",
    symbol: "CRV",
    address: "0x172370d5Cd63279eFa6d502DAB29171933a610AF",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/curve.png",
      large: "https://mint.club/assets/tokens/large/curve.png"
    }
  },
  "0x61299774020dA444Af134c82fa83E3810b309991": {
    name: "Render Token",
    symbol: "RNDR",
    address: "0x61299774020dA444Af134c82fa83E3810b309991",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/11636/small/rndr.png",
      large: "https://assets.coingecko.com/coins/images/11636/large/rndr.png"
    }
  },
  "0xE0B52e49357Fd4DAf2c15e02058DCE6BC0057db4": {
    name: "agEUR",
    symbol: "agEUR",
    address: "0xE0B52e49357Fd4DAf2c15e02058DCE6BC0057db4",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/ageur.png",
      large: "https://mint.club/assets/tokens/large/ageur.png"
    }
  },
  "0x50B728D8D964fd00C2d0AAD81718b71311feF68a": {
    name: "Synthetix Network Token",
    symbol: "SNX",
    address: "0x50B728D8D964fd00C2d0AAD81718b71311feF68a",
    decimals: 18,
    image: {
      small: "https://assets.coingecko.com/coins/images/3406/small/SNX.png",
      large: "https://assets.coingecko.com/coins/images/3406/large/SNX.png"
    }
  }
};

const SEPOLIA_TOKENS = {
  "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14": {
    name: "Wrapped Ether",
    symbol: "WETH",
    address: "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14",
    decimals: 18,
    image: {
      small: "https://mint.club/assets/tokens/small/weth.png",
      large: "https://mint.club/assets/tokens/large/weth.png"
    }
  }
};

const COINGECKO_NETWORK_IDS = {
  [chains.mainnet.id]: "ethereum",
  [chains.optimism.id]: "optimistic-ethereum",
  [chains.arbitrum.id]: "arbitrum-one",
  [chains.avalanche.id]: "avalanche",
  [chains.base.id]: "base",
  [chains.polygon.id]: "polygon-pos",
  [chains.bsc.id]: "binance-smart-chain",
  [chains.sepolia.id]: "ethereum",
  // sepolia not supported by coingecko API
  [chains.blast.id]: "ethereum",
  // blast not supported by coingecko API
  [chains.blastSepolia.id]: "ethereum",
  // blast sepolia not supported by coingecko API
  [chains.avalancheFuji.id]: "ethereum"
  // avalanche-fuji not supported by coingecko API
};
const WRAPPED_NATIVE_TOKENS = {
  [chains.mainnet.id]: {
    image: "https://mint.club/assets/tokens/large/eth.png",
    tokenAddress: "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2",
    nativeSymbol: "ETH",
    oneInchSymbol: "USDT",
    decimals: 18
  },
  [chains.optimism.id]: {
    image: "https://mint.club/assets/tokens/large/eth.png",
    tokenAddress: "0x4200000000000000000000000000000000000006",
    nativeSymbol: "ETH",
    oneInchSymbol: "USDT",
    decimals: 18
  },
  [chains.arbitrum.id]: {
    image: "https://mint.club/assets/tokens/large/eth.png",
    tokenAddress: "0x82aF49447D8a07e3bd95BD0d56f35241523fBab1",
    nativeSymbol: "ETH",
    oneInchSymbol: "USDT",
    decimals: 18
  },
  [chains.avalanche.id]: {
    image: "https://mint.club/assets/tokens/large/avalanche.png",
    tokenAddress: "0xB31f66AA3C1e785363F0875A1B74E27b85FD66c7",
    nativeSymbol: "AVAX",
    oneInchSymbol: "USDT",
    decimals: 18
  },
  [chains.polygon.id]: {
    image: "https://mint.club/assets/tokens/large/matic.png",
    tokenAddress: "0x0d500B1d8E8eF31E21C99d1Db9A6444d3ADf1270",
    nativeSymbol: "MATIC",
    oneInchSymbol: "USDT",
    decimals: 18
  },
  [chains.bsc.id]: {
    image: "https://mint.club/assets/tokens/large/bnb.png",
    tokenAddress: "0xbb4CdB9CBd36B01bD1cBaEBF2De08d9173bc095c",
    nativeSymbol: "BNB",
    oneInchSymbol: "USDT",
    decimals: 18
  },
  [chains.base.id]: {
    image: "https://mint.club/assets/tokens/large/eth.png",
    tokenAddress: "0x4200000000000000000000000000000000000006",
    nativeSymbol: "ETH",
    oneInchSymbol: "USDbC",
    decimals: 18
  },
  [chains.sepolia.id]: {
    image: "https://mint.club/assets/tokens/large/eth.png",
    tokenAddress: "0xfFf9976782d46CC05630D1f6eBAb18b2324d6B14",
    nativeSymbol: "ETH",
    oneInchSymbol: "USDT",
    decimals: 18
  },
  [chains.blast.id]: {
    image: "https://mint.club/assets/tokens/large/blast.png",
    tokenAddress: "0x4300000000000000000000000000000000000004",
    nativeSymbol: "ETH",
    oneInchSymbol: "USDB",
    decimals: 18
  },
  [chains.blastSepolia.id]: {
    image: "https://mint.club/assets/tokens/large/blast.png",
    tokenAddress: "0x4200000000000000000000000000000000000023",
    nativeSymbol: "ETH",
    oneInchSymbol: "USDB",
    decimals: 18
  },
  [chains.avalancheFuji.id]: {
    image: "https://mint.club/assets/tokens/large/avalanche.png",
    tokenAddress: "0xd00ae08403B9bbb9124bB305C09058E32C39A48c",
    nativeSymbol: "AVAX",
    oneInchSymbol: "USDT",
    decimals: 18
  }
};
const TOKENS = {
  // export const TOKENS = {
  [chains.mainnet.id]: MAINNET_TOKENS,
  [chains.optimism.id]: OPTIMISM_TOKENS,
  [chains.arbitrum.id]: ARBITRUM_TOKENS,
  [chains.avalanche.id]: AVALANCHE_TOKENS,
  [chains.polygon.id]: POLYGON_TOKENS,
  [chains.bsc.id]: BSC_TOKENS,
  [chains.base.id]: BASE_TOKENS,
  [chains.blast.id]: BLAST_TOKENS,
  [chains.blastSepolia.id]: BLAST_SEPOLIA_TOKENS,
  [chains.sepolia.id]: SEPOLIA_TOKENS,
  [chains.avalancheFuji.id]: AVALANCHE_FUJI_TOKENS
};

const MCV2_WALLET_STATE_LOCALSTORAGE = "mcv2_wallet_state";
class Client {
  static instance;
  walletClient;
  // these are always defined, singleton
  publicClients = {};
  chainId;
  // last chain id used
  constructor() {
    if (Client.instance) {
      return Client.instance;
    }
    Client.instance = this;
  }
  async connect(provider) {
    let addressToReturn = null;
    if (this.walletClient?.account)
      addressToReturn = this.walletClient.account.address;
    if (this.walletClient) {
      const [address] = await this.walletClient?.requestAddresses();
      this.walletClient = viem.createWalletClient({
        account: address,
        transport: viem.custom(provider ?? this.walletClient.transport)
      });
      addressToReturn = address;
    } else {
      if (window.ethereum === void 0)
        throw new NoEthereumProviderError();
      this.walletClient = viem.createWalletClient({
        transport: viem.custom(provider ?? window.ethereum)
      });
      const [address] = await this.walletClient?.requestAddresses();
      this.walletClient = viem.createWalletClient({
        account: address,
        transport: viem.custom(provider ?? window.ethereum)
      });
      addressToReturn = address;
    }
    if (addressToReturn)
      this.walletState = "connected";
    return addressToReturn;
  }
  get walletState() {
    return window?.localStorage?.getItem(MCV2_WALLET_STATE_LOCALSTORAGE) ?? "none";
  }
  set walletState(newState) {
    window?.localStorage?.setItem(MCV2_WALLET_STATE_LOCALSTORAGE, newState);
  }
  async change() {
    await this.walletClient?.request({
      method: "wallet_requestPermissions",
      params: [
        {
          eth_accounts: {}
        }
      ]
    });
  }
  disconnect() {
    this.walletClient = void 0;
    this.walletState = "disconnected";
  }
  async account() {
    if (this.walletState === "disconnected")
      return null;
    if (!this.walletClient && window?.ethereum !== void 0) {
      this.walletClient = viem.createWalletClient({
        transport: viem.custom(window.ethereum)
      });
    }
    const accounts = await this.walletClient?.getAddresses();
    return accounts?.[0] || null;
  }
  async getNativeBalance(params) {
    const { walletAddress, chainId } = params || {};
    if (chainId !== void 0 && walletAddress)
      return this._getPublicClient(chainId).getBalance({ address: walletAddress });
    await this.connect();
    const address = await this.account();
    const connectedChain = this.walletClient?.chain?.id;
    if (!address || connectedChain === void 0)
      throw new WalletNotConnectedError();
    return this._getPublicClient(connectedChain).getBalance({
      address
    });
  }
  _getPublicClient(id) {
    if (this.publicClients[id] !== void 0)
      return this.publicClients[id];
    const chain = Object.values(chains__namespace).find((chain2) => chain2.id === id);
    if (!chain)
      throw new ChainNotSupportedError(id);
    this.publicClients[chain.id] = viem.createPublicClient({
      chain,
      transport: viem.fallback(chainRPCFallbacks(chain), DEFAULT_RANK_OPTIONS)
    });
    this.publicClients[chain.id].transport.onResponse((response) => {
      if (!response.response && response.status === "success") {
        throw new Error("Empty RPC Response");
      }
    });
    return this.publicClients[chain.id];
  }
  getWalletClient() {
    return this.walletClient;
  }
  withPublicClient(publicClient) {
    if (publicClient.chain?.id === void 0)
      throw new ChainNotSupportedError(publicClient.chain);
    this.publicClients[publicClient.chain.id] = publicClient;
    return this;
  }
  withWalletClient(walletClient) {
    this.walletClient = walletClient;
    return this;
  }
  withPrivateKey(privateKey) {
    const account = accounts.privateKeyToAccount(privateKey);
    this.walletClient = viem.createWalletClient({
      account,
      transport: viem.http()
    });
    return this;
  }
  withAccount(account, provider) {
    const providerToUse = provider || window.ethereum;
    this.walletClient = viem.createWalletClient({
      account,
      transport: viem.custom(providerToUse)
    });
    return this;
  }
  async withProvider(provider) {
    this.walletClient = viem.createWalletClient({
      transport: viem.custom(provider)
    });
    return this;
  }
}

class GenericContractLogic {
  abi;
  contractType;
  chainId;
  clientHelper;
  chain;
  constructor(params) {
    const { chainId, type, abi } = params;
    this.contractType = type;
    this.abi = abi;
    this.chainId = chainId;
    this.chain = getChain(chainId);
    this.clientHelper = new Client();
  }
  read(params) {
    const { functionName } = params;
    const args = "args" in params ? params.args : void 0;
    let address;
    if ("tokenAddress" in params) {
      address = params.tokenAddress;
    } else {
      address = getMintClubContractAddress(this.contractType, this.chainId);
    }
    const publicClient = this.clientHelper._getPublicClient(this.chainId);
    return publicClient.readContract({
      abi: this.abi,
      address,
      functionName,
      args
    });
  }
  async write(params) {
    const { functionName, value, debug, onError, onSignatureRequest, onSigned, onSuccess } = params;
    let args, simulationArgs;
    try {
      await this.clientHelper.connect();
      const walletClient = this.clientHelper.getWalletClient();
      if (!walletClient) {
        this.clientHelper.connect();
        return;
      }
      let address;
      if ("tokenAddress" in params) {
        address = params.tokenAddress;
      } else {
        address = getMintClubContractAddress(this.contractType, this.chainId);
      }
      await walletClient.addChain({ chain: this.chain });
      await walletClient.switchChain({ id: this.chainId });
      args = "args" in params ? params.args : void 0;
      simulationArgs = {
        chain: this.chain,
        account: walletClient.account,
        abi: this.abi,
        address,
        functionName,
        args,
        ...value !== void 0 && { value }
      };
      debug?.(simulationArgs);
      const { request } = await this.clientHelper._getPublicClient(this.chainId).simulateContract(simulationArgs);
      onSignatureRequest?.();
      const tx = await walletClient.writeContract(request);
      onSigned?.(tx);
      const receipt = await this.clientHelper._getPublicClient(this.chainId).waitForTransactionReceipt({
        hash: tx
      });
      onSuccess?.(receipt);
      return receipt;
    } catch (e) {
      if (e) {
        Object.assign(e, { functionName, args, simulationArgs, value });
      }
      onError?.(e);
      return;
    }
  }
}

class GenericContract {
  contractType;
  abi;
  constructor(type) {
    this.contractType = type;
    if (type === "BOND") {
      this.abi = BOND_ABI;
    } else if (type === "ERC20") {
      this.abi = ERC20_ABI;
    } else if (type === "ERC1155") {
      this.abi = ERC1155_ABI;
    } else if (type === "LOCKER") {
      this.abi = LOCKER_ABI;
    } else if (type === "MERKLE") {
      this.abi = MERKLE_ABI;
    } else if (type === "ZAP") {
      this.abi = ZAP_ABI;
    } else if (type === "ONEINCH") {
      this.abi = ONEINCH_ABI;
    } else {
      throw new Error(`Contract type ${type} not supported`);
    }
  }
  network(id) {
    let chainId;
    if (typeof id === "string") {
      chainId = chainStringToId(id);
    } else {
      chainId = id;
    }
    return new GenericContractLogic({
      chainId,
      type: this.contractType,
      abi: this.abi
    });
  }
}

const bondContract = new GenericContract("BOND");
const erc20Contract = new GenericContract("ERC20");
const erc1155Contract = new GenericContract("ERC1155");
const zapContract = new GenericContract("ZAP");
const airdropContract = new GenericContract("MERKLE");
const lockupContract = new GenericContract("LOCKER");
const oneInchContract = new GenericContract("ONEINCH");

class Bond {
  chainId;
  constructor(chainId) {
    this.chainId = chainId;
  }
  getCreationFee() {
    return bondContract.network(this.chainId).read({
      functionName: "creationFee"
    });
  }
  getTokensByReserveToken(params) {
    const { reserveToken, start = 0, end = 1e3 } = params;
    return bondContract.network(this.chainId).read({
      functionName: "getTokensByReserveToken",
      args: [reserveToken, BigInt(start), BigInt(end)]
    });
  }
  getTokensByCreator(params) {
    const { creator, start = 0, end = 1e3 } = params;
    return bondContract.network(this.chainId).read({
      functionName: "getTokensByCreator",
      args: [creator, BigInt(start), BigInt(end)]
    });
  }
}

function computeCreate2Address(chainId, tokenType, tokenSymbol) {
  const bondAddress = getMintClubContractAddress("BOND", chainId);
  const tokenImplementation = getMintClubContractAddress(
    tokenType === "ERC20" ? "ERC20" : "ERC1155",
    chainId
  );
  const hexedSymbol = viem.stringToHex(tokenSymbol);
  const packed = `0x${[bondAddress, hexedSymbol].map((x) => x?.replace("0x", "")).join("").toLowerCase()}`;
  const salt = viem.keccak256(packed);
  const creationCode = [
    "0x3d602d80600a3d3981f3363d3d373d3d3d363d73",
    tokenImplementation?.replace(/0x/, "").toLowerCase(),
    "5af43d82803e903d91602b57fd5bf3"
  ].join("");
  const params = `0x${["ff", bondAddress, salt, viem.keccak256(creationCode)].map((x) => x?.replace(/0x/, "")).join("")}`;
  const hexed = viem.hexToBytes(params);
  const hash = viem.keccak256(hexed);
  const address = viem.getAddress(`0x${hash.slice(-40)}`);
  return address;
}
function createRandomAddress() {
  const randBytes = crypto.randomBytes(20);
  return viem.bytesToHex(randBytes);
}

const { uniqBy } = lodash;
var CurveEnum = /* @__PURE__ */ ((CurveEnum2) => {
  CurveEnum2["FLAT"] = "FLAT";
  CurveEnum2["LINEAR"] = "LINEAR";
  CurveEnum2["EXPONENTIAL"] = "EXPONENTIAL";
  CurveEnum2["LOGARITHMIC"] = "LOGARITHMIC";
  return CurveEnum2;
})(CurveEnum || {});
const graphTypes = ["FLAT" /* FLAT */, "LINEAR" /* LINEAR */, "EXPONENTIAL" /* EXPONENTIAL */, "LOGARITHMIC" /* LOGARITHMIC */];
function formatGraphPoint(value, maxDecimalPoints) {
  const maxWeiDecimals = 18;
  let formattedValue;
  if (maxDecimalPoints !== void 0 && maxWeiDecimals > maxDecimalPoints) {
    formattedValue = Number(value?.toFixed(maxDecimalPoints));
  } else {
    formattedValue = Number(value?.toFixed(maxWeiDecimals));
  }
  if (value !== 0 && formattedValue === 0)
    return value;
  return formattedValue;
}
function generateSteps(form) {
  const {
    tokenType,
    reserveToken,
    curveData: {
      curveType,
      stepCount: _stepCount,
      maxSupply,
      creatorAllocation = 0,
      initialMintingPrice,
      finalMintingPrice
    }
  } = form;
  const maxPrice = finalMintingPrice;
  const startingPrice = initialMintingPrice;
  const stepPoints = [];
  let stepCount = curveType === "FLAT" /* FLAT */ ? 1 : _stepCount;
  if (tokenType === "ERC1155" && stepCount > maxSupply) {
    stepCount = maxSupply;
  }
  let extraStepCount = 0;
  if (startingPrice === 0 || creatorAllocation > 0) {
    extraStepCount = 1;
  }
  const deltaX = (maxSupply - creatorAllocation) / (stepCount + extraStepCount);
  const totalX = maxSupply - creatorAllocation - deltaX;
  const totalY = maxPrice - startingPrice;
  const coefficientExponential = totalY / Math.pow(totalX, 2);
  const exponent = 0.5;
  const coefficientPower = totalY / Math.pow(totalX, exponent);
  for (let i = extraStepCount; i <= stepCount + extraStepCount; i++) {
    let x = i * deltaX + creatorAllocation;
    if (tokenType === "ERC1155")
      x = Math.ceil(x);
    let y;
    switch (curveType) {
      case "FLAT" /* FLAT */:
        y = startingPrice;
        break;
      case "LINEAR" /* LINEAR */:
        const stepPerPrice = totalY / totalX;
        y = stepPerPrice * (x - extraStepCount - creatorAllocation) + startingPrice;
        break;
      case "EXPONENTIAL" /* EXPONENTIAL */:
        y = startingPrice + coefficientExponential * Math.pow(x - extraStepCount - creatorAllocation, 2);
        break;
      case "LOGARITHMIC" /* LOGARITHMIC */:
        if (x - creatorAllocation === 0)
          y = startingPrice;
        else {
          y = startingPrice + coefficientPower * Math.pow(x - extraStepCount - creatorAllocation, exponent);
        }
        break;
      default:
        y = 0;
    }
    const leadingZeros = countLeadingZeros(handleScientificNotation(deltaX));
    if (tokenType === "ERC1155") {
      x = Number(x.toFixed(0));
    } else if (leadingZeros !== void 0 && leadingZeros > 0) {
      x = Number(x.toFixed(leadingZeros + 3));
    } else {
      x = formatGraphPoint(x, 18);
    }
    y = Math.max(Math.min(y, maxPrice), initialMintingPrice);
    y = formatGraphPoint(y, reserveToken.decimals);
    if (i === stepCount && curveType !== "FLAT" /* FLAT */) {
      stepPoints.push({ x, y: maxPrice });
    } else {
      stepPoints.push({ x, y: Math.min(y || 0, maxPrice) });
    }
  }
  if (startingPrice === 0) {
    return generateSteps({
      ...form,
      curveData: {
        ...form.curveData,
        initialMintingPrice: stepPoints[0].y
      }
    });
  }
  let mergeCount = 0;
  let clonedPoints = structuredClone(stepPoints);
  for (let i = 0; i < clonedPoints.length - 2; i++) {
    if (clonedPoints[i].x === clonedPoints[i + 1].x) {
      clonedPoints.splice(i, 1);
      mergeCount++;
      i--;
    }
  }
  const finalData = uniqBy(clonedPoints, (point) => `${point.x}-${point.y}`).map((point) => {
    return { rangeTo: point.x, price: point.y };
  });
  return { stepData: finalData, mergeCount };
}
function calculateArea(steps, partialIndex) {
  const clonedSteps = structuredClone(steps);
  clonedSteps.sort((a, b) => a.x - b.x);
  let intervalArea = 0;
  let totalArea = 0;
  let lastIndex = clonedSteps.length - 1;
  if (partialIndex !== void 0) {
    lastIndex = Math.min(lastIndex, partialIndex);
  }
  for (let i = 1; i <= lastIndex; i++) {
    const height = clonedSteps[i - 1].y;
    const width = clonedSteps[i].x - clonedSteps[i - 1].x;
    if (width > 0 && height > 0) {
      const plotArea = width * height;
      totalArea += plotArea;
      if (partialIndex === i) {
        intervalArea = plotArea;
      }
    }
  }
  return { intervalArea, totalArea };
}
function generateTableData(steps) {
  const clonedSteps = structuredClone(steps);
  clonedSteps.sort((a, b) => a.x - b.x);
  let data = [];
  let totalTVL = 0;
  for (let i = 1; i < clonedSteps.length; i++) {
    const height = clonedSteps[i - 1].y;
    const width = clonedSteps[i].x - clonedSteps[i - 1].x;
    const obj = {};
    obj.start = clonedSteps[i - 1].x;
    obj.end = clonedSteps[i].x;
    obj.price = clonedSteps[i - 1].y;
    if (width > 0 && height > 0) {
      const tvl = width * height;
      obj.tvl = tvl;
      totalTVL += tvl;
    }
    data.push(obj);
  }
  return { data, totalTVL };
}

const { cloneDeep } = lodash;
function generateCreateArgs(params) {
  const {
    tokenType,
    name,
    symbol,
    curveData,
    reserveToken,
    buyRoyalty = 0.03,
    sellRoyalty = 0.03,
    stepData: _stepData
  } = params;
  if (curveData === void 0 && _stepData === void 0) {
    throw new CreationError("Either curveData or stepData is required for creation");
  }
  const stepRanges = [];
  const stepPrices = [];
  let stepData = [];
  const { creatorAllocation = 0, maxSupply = 0 } = curveData || {};
  if (curveData) {
    const { stepData: generatedSteps } = generateSteps({
      ...params,
      curveData
    });
    if (creatorAllocation > maxSupply) {
      throw new CreationError("Generating argument for creation failed", {
        metaMessages: ["Creator allocation cannot be greater than max supply"]
      });
    }
    stepData = generatedSteps;
    const cloned = cloneDeep(generatedSteps);
    for (let i = cloned.length - 1; i > 0; i--) {
      cloned[i].price = cloned[i - 1].price;
    }
    cloned.shift();
    stepData = cloned;
    if (creatorAllocation > 0) {
      stepRanges.unshift(wei$1(creatorAllocation, tokenType === "ERC20" ? 18 : 0));
      stepPrices.unshift(0n);
    }
    if (stepData[0].price !== curveData.initialMintingPrice) {
      throw new CreationError(`Generated step data's initial price does not match your desired value.`, {
        metaMessages: ["Please try a different step count"]
      });
    } else if (stepData[stepData.length - 1].price !== curveData.finalMintingPrice) {
      throw new CreationError(`Generated step data's final price does not match your desired value.`, {
        metaMessages: ["Please try a different step count"]
      });
    }
  } else {
    stepData = _stepData;
  }
  stepData.forEach(({ rangeTo, price }) => {
    if (isNaN(rangeTo) || isNaN(price) || rangeTo < 0 || price < 0) {
      throw new CreationError("Invalid arguments passed for creation", {
        metaMessages: ["Please double check the step data"]
      });
    }
    stepRanges.push(wei$1(rangeTo, tokenType === "ERC20" ? 18 : 0));
    stepPrices.push(wei$1(price, reserveToken.decimals));
  });
  for (let i = 0; i < stepPrices.length; i++) {
    if (stepPrices[i] === stepPrices[i + 1]) {
      stepRanges.splice(i, 1);
      stepPrices.splice(i, 1);
      i--;
    }
  }
  if (stepRanges.length === 0 || stepPrices.length === 0 || stepRanges.length !== stepPrices.length) {
    throw new CreationError("Invalid step data. Please double check the step data");
  }
  const tokenParams = {
    name,
    symbol
  };
  const bondParams = {
    mintRoyalty: buyRoyalty * 100,
    burnRoyalty: sellRoyalty * 100,
    reserveToken: reserveToken.address,
    maxSupply: stepRanges[stepRanges.length - 1],
    stepRanges,
    stepPrices
  };
  return { tokenParams, bondParams };
}

// eslint-lint-disable-next-line @typescript-eslint/naming-convention
class HTTPError extends Error {
    constructor(response, request, options) {
        const code = (response.status || response.status === 0) ? response.status : '';
        const title = response.statusText || '';
        const status = `${code} ${title}`.trim();
        const reason = status ? `status code ${status}` : 'an unknown error';
        super(`Request failed with ${reason}`);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'HTTPError';
        this.response = response;
        this.request = request;
        this.options = options;
    }
}

class TimeoutError extends Error {
    constructor(request) {
        super('Request timed out');
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'TimeoutError';
        this.request = request;
    }
}

// eslint-disable-next-line @typescript-eslint/ban-types
const isObject = (value) => value !== null && typeof value === 'object';

const validateAndMerge = (...sources) => {
    for (const source of sources) {
        if ((!isObject(source) || Array.isArray(source)) && source !== undefined) {
            throw new TypeError('The `options` argument must be an object');
        }
    }
    return deepMerge({}, ...sources);
};
const mergeHeaders = (source1 = {}, source2 = {}) => {
    const result = new globalThis.Headers(source1);
    const isHeadersInstance = source2 instanceof globalThis.Headers;
    const source = new globalThis.Headers(source2);
    for (const [key, value] of source.entries()) {
        if ((isHeadersInstance && value === 'undefined') || value === undefined) {
            result.delete(key);
        }
        else {
            result.set(key, value);
        }
    }
    return result;
};
// TODO: Make this strongly-typed (no `any`).
const deepMerge = (...sources) => {
    let returnValue = {};
    let headers = {};
    for (const source of sources) {
        if (Array.isArray(source)) {
            if (!Array.isArray(returnValue)) {
                returnValue = [];
            }
            returnValue = [...returnValue, ...source];
        }
        else if (isObject(source)) {
            for (let [key, value] of Object.entries(source)) {
                if (isObject(value) && key in returnValue) {
                    value = deepMerge(returnValue[key], value);
                }
                returnValue = { ...returnValue, [key]: value };
            }
            if (isObject(source.headers)) {
                headers = mergeHeaders(headers, source.headers);
                returnValue.headers = headers;
            }
        }
    }
    return returnValue;
};

const supportsRequestStreams = (() => {
    let duplexAccessed = false;
    let hasContentType = false;
    const supportsReadableStream = typeof globalThis.ReadableStream === 'function';
    const supportsRequest = typeof globalThis.Request === 'function';
    if (supportsReadableStream && supportsRequest) {
        hasContentType = new globalThis.Request('https://empty.invalid', {
            body: new globalThis.ReadableStream(),
            method: 'POST',
            // @ts-expect-error - Types are outdated.
            get duplex() {
                duplexAccessed = true;
                return 'half';
            },
        }).headers.has('Content-Type');
    }
    return duplexAccessed && !hasContentType;
})();
const supportsAbortController = typeof globalThis.AbortController === 'function';
const supportsResponseStreams = typeof globalThis.ReadableStream === 'function';
const supportsFormData = typeof globalThis.FormData === 'function';
const requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];
const responseTypes = {
    json: 'application/json',
    text: 'text/*',
    formData: 'multipart/form-data',
    arrayBuffer: '*/*',
    blob: '*/*',
};
// The maximum value of a 32bit int (see issue #117)
const maxSafeTimeout = 2147483647;
const stop = Symbol('stop');
const kyOptionKeys = {
    json: true,
    parseJson: true,
    searchParams: true,
    prefixUrl: true,
    retry: true,
    timeout: true,
    hooks: true,
    throwHttpErrors: true,
    onDownloadProgress: true,
    fetch: true,
};
const requestOptionsRegistry = {
    method: true,
    headers: true,
    body: true,
    mode: true,
    credentials: true,
    cache: true,
    redirect: true,
    referrer: true,
    referrerPolicy: true,
    integrity: true,
    keepalive: true,
    signal: true,
    window: true,
    dispatcher: true,
    duplex: true,
};

const normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
const retryMethods = ['get', 'put', 'head', 'delete', 'options', 'trace'];
const retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
const retryAfterStatusCodes = [413, 429, 503];
const defaultRetryOptions = {
    limit: 2,
    methods: retryMethods,
    statusCodes: retryStatusCodes,
    afterStatusCodes: retryAfterStatusCodes,
    maxRetryAfter: Number.POSITIVE_INFINITY,
    backoffLimit: Number.POSITIVE_INFINITY,
    delay: attemptCount => 0.3 * (2 ** (attemptCount - 1)) * 1000,
};
const normalizeRetryOptions = (retry = {}) => {
    if (typeof retry === 'number') {
        return {
            ...defaultRetryOptions,
            limit: retry,
        };
    }
    if (retry.methods && !Array.isArray(retry.methods)) {
        throw new Error('retry.methods must be an array');
    }
    if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
        throw new Error('retry.statusCodes must be an array');
    }
    return {
        ...defaultRetryOptions,
        ...retry,
        afterStatusCodes: retryAfterStatusCodes,
    };
};

// `Promise.race()` workaround (#91)
async function timeout(request, init, abortController, options) {
    return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
            if (abortController) {
                abortController.abort();
            }
            reject(new TimeoutError(request));
        }, options.timeout);
        void options
            .fetch(request, init)
            .then(resolve)
            .catch(reject)
            .then(() => {
            clearTimeout(timeoutId);
        });
    });
}

// https://github.com/sindresorhus/delay/tree/ab98ae8dfcb38e1593286c94d934e70d14a4e111
async function delay(ms, { signal }) {
    return new Promise((resolve, reject) => {
        if (signal) {
            signal.throwIfAborted();
            signal.addEventListener('abort', abortHandler, { once: true });
        }
        function abortHandler() {
            clearTimeout(timeoutId);
            reject(signal.reason);
        }
        const timeoutId = setTimeout(() => {
            signal?.removeEventListener('abort', abortHandler);
            resolve();
        }, ms);
    });
}

const findUnknownOptions = (request, options) => {
    const unknownOptions = {};
    for (const key in options) {
        if (!(key in requestOptionsRegistry) && !(key in kyOptionKeys) && !(key in request)) {
            unknownOptions[key] = options[key];
        }
    }
    return unknownOptions;
};

class Ky {
    static create(input, options) {
        const ky = new Ky(input, options);
        const function_ = async () => {
            if (typeof ky._options.timeout === 'number' && ky._options.timeout > maxSafeTimeout) {
                throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
            }
            // Delay the fetch so that body method shortcuts can set the Accept header
            await Promise.resolve();
            let response = await ky._fetch();
            for (const hook of ky._options.hooks.afterResponse) {
                // eslint-disable-next-line no-await-in-loop
                const modifiedResponse = await hook(ky.request, ky._options, ky._decorateResponse(response.clone()));
                if (modifiedResponse instanceof globalThis.Response) {
                    response = modifiedResponse;
                }
            }
            ky._decorateResponse(response);
            if (!response.ok && ky._options.throwHttpErrors) {
                let error = new HTTPError(response, ky.request, ky._options);
                for (const hook of ky._options.hooks.beforeError) {
                    // eslint-disable-next-line no-await-in-loop
                    error = await hook(error);
                }
                throw error;
            }
            // If `onDownloadProgress` is passed, it uses the stream API internally
            /* istanbul ignore next */
            if (ky._options.onDownloadProgress) {
                if (typeof ky._options.onDownloadProgress !== 'function') {
                    throw new TypeError('The `onDownloadProgress` option must be a function');
                }
                if (!supportsResponseStreams) {
                    throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');
                }
                return ky._stream(response.clone(), ky._options.onDownloadProgress);
            }
            return response;
        };
        const isRetriableMethod = ky._options.retry.methods.includes(ky.request.method.toLowerCase());
        const result = (isRetriableMethod ? ky._retry(function_) : function_());
        for (const [type, mimeType] of Object.entries(responseTypes)) {
            result[type] = async () => {
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                ky.request.headers.set('accept', ky.request.headers.get('accept') || mimeType);
                const awaitedResult = await result;
                const response = awaitedResult.clone();
                if (type === 'json') {
                    if (response.status === 204) {
                        return '';
                    }
                    const arrayBuffer = await response.clone().arrayBuffer();
                    const responseSize = arrayBuffer.byteLength;
                    if (responseSize === 0) {
                        return '';
                    }
                    if (options.parseJson) {
                        return options.parseJson(await response.text());
                    }
                }
                return response[type]();
            };
        }
        return result;
    }
    // eslint-disable-next-line complexity
    constructor(input, options = {}) {
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "abortController", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_retryCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_input", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._input = input;
        const isCredentialsSupported = 'credentials' in Request.prototype;
        this._options = {
            credentials: isCredentialsSupported ? this._input.credentials : undefined,
            ...options,
            headers: mergeHeaders(this._input.headers, options.headers),
            hooks: deepMerge({
                beforeRequest: [],
                beforeRetry: [],
                beforeError: [],
                afterResponse: [],
            }, options.hooks),
            method: normalizeRequestMethod(options.method ?? this._input.method),
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            prefixUrl: String(options.prefixUrl || ''),
            retry: normalizeRetryOptions(options.retry),
            throwHttpErrors: options.throwHttpErrors !== false,
            timeout: options.timeout ?? 10000,
            fetch: options.fetch ?? globalThis.fetch.bind(globalThis),
        };
        if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
            throw new TypeError('`input` must be a string, URL, or Request');
        }
        if (this._options.prefixUrl && typeof this._input === 'string') {
            if (this._input.startsWith('/')) {
                throw new Error('`input` must not begin with a slash when using `prefixUrl`');
            }
            if (!this._options.prefixUrl.endsWith('/')) {
                this._options.prefixUrl += '/';
            }
            this._input = this._options.prefixUrl + this._input;
        }
        if (supportsAbortController) {
            this.abortController = new globalThis.AbortController();
            if (this._options.signal) {
                const originalSignal = this._options.signal;
                this._options.signal.addEventListener('abort', () => {
                    this.abortController.abort(originalSignal.reason);
                });
            }
            this._options.signal = this.abortController.signal;
        }
        if (supportsRequestStreams) {
            // @ts-expect-error - Types are outdated.
            this._options.duplex = 'half';
        }
        this.request = new globalThis.Request(this._input, this._options);
        if (this._options.searchParams) {
            // eslint-disable-next-line unicorn/prevent-abbreviations
            const textSearchParams = typeof this._options.searchParams === 'string'
                ? this._options.searchParams.replace(/^\?/, '')
                : new URLSearchParams(this._options.searchParams).toString();
            // eslint-disable-next-line unicorn/prevent-abbreviations
            const searchParams = '?' + textSearchParams;
            const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
            // To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one
            if (((supportsFormData && this._options.body instanceof globalThis.FormData)
                || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {
                this.request.headers.delete('content-type');
            }
            // The spread of `this.request` is required as otherwise it misses the `duplex` option for some reason and throws.
            this.request = new globalThis.Request(new globalThis.Request(url, { ...this.request }), this._options);
        }
        if (this._options.json !== undefined) {
            this._options.body = JSON.stringify(this._options.json);
            this.request.headers.set('content-type', this._options.headers.get('content-type') ?? 'application/json');
            this.request = new globalThis.Request(this.request, { body: this._options.body });
        }
    }
    _calculateRetryDelay(error) {
        this._retryCount++;
        if (this._retryCount <= this._options.retry.limit && !(error instanceof TimeoutError)) {
            if (error instanceof HTTPError) {
                if (!this._options.retry.statusCodes.includes(error.response.status)) {
                    return 0;
                }
                const retryAfter = error.response.headers.get('Retry-After');
                if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
                    let after = Number(retryAfter);
                    if (Number.isNaN(after)) {
                        after = Date.parse(retryAfter) - Date.now();
                    }
                    else {
                        after *= 1000;
                    }
                    if (this._options.retry.maxRetryAfter !== undefined && after > this._options.retry.maxRetryAfter) {
                        return 0;
                    }
                    return after;
                }
                if (error.response.status === 413) {
                    return 0;
                }
            }
            const retryDelay = this._options.retry.delay(this._retryCount);
            return Math.min(this._options.retry.backoffLimit, retryDelay);
        }
        return 0;
    }
    _decorateResponse(response) {
        if (this._options.parseJson) {
            response.json = async () => this._options.parseJson(await response.text());
        }
        return response;
    }
    async _retry(function_) {
        try {
            return await function_();
        }
        catch (error) {
            const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
            if (ms !== 0 && this._retryCount > 0) {
                await delay(ms, { signal: this._options.signal });
                for (const hook of this._options.hooks.beforeRetry) {
                    // eslint-disable-next-line no-await-in-loop
                    const hookResult = await hook({
                        request: this.request,
                        options: this._options,
                        error: error,
                        retryCount: this._retryCount,
                    });
                    // If `stop` is returned from the hook, the retry process is stopped
                    if (hookResult === stop) {
                        return;
                    }
                }
                return this._retry(function_);
            }
            throw error;
        }
    }
    async _fetch() {
        for (const hook of this._options.hooks.beforeRequest) {
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(this.request, this._options);
            if (result instanceof Request) {
                this.request = result;
                break;
            }
            if (result instanceof Response) {
                return result;
            }
        }
        const nonRequestOptions = findUnknownOptions(this.request, this._options);
        if (this._options.timeout === false) {
            return this._options.fetch(this.request.clone(), nonRequestOptions);
        }
        return timeout(this.request.clone(), nonRequestOptions, this.abortController, this._options);
    }
    /* istanbul ignore next */
    _stream(response, onDownloadProgress) {
        const totalBytes = Number(response.headers.get('content-length')) || 0;
        let transferredBytes = 0;
        if (response.status === 204) {
            if (onDownloadProgress) {
                onDownloadProgress({ percent: 1, totalBytes, transferredBytes }, new Uint8Array());
            }
            return new globalThis.Response(null, {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers,
            });
        }
        return new globalThis.Response(new globalThis.ReadableStream({
            async start(controller) {
                const reader = response.body.getReader();
                if (onDownloadProgress) {
                    onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
                }
                async function read() {
                    const { done, value } = await reader.read();
                    if (done) {
                        controller.close();
                        return;
                    }
                    if (onDownloadProgress) {
                        transferredBytes += value.byteLength;
                        const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
                        onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
                    }
                    controller.enqueue(value);
                    await read();
                }
                await read();
            },
        }), {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
        });
    }
}

/*! MIT License  Sindre Sorhus */
const createInstance = (defaults) => {
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    const ky = (input, options) => Ky.create(input, validateAndMerge(defaults, options));
    for (const method of requestMethods) {
        // eslint-disable-next-line @typescript-eslint/promise-function-async
        ky[method] = (input, options) => Ky.create(input, validateAndMerge(defaults, options, { method }));
    }
    ky.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
    ky.extend = (newDefaults) => createInstance(validateAndMerge(defaults, newDefaults));
    ky.stop = stop;
    return ky;
};
const ky = createInstance();

class ApiError {
  status;
  message;
  constructor({ status, message }) {
    this.status = status;
    this.message = message || "An unexpected error occurred";
  }
}
const baseFetcher = ky.extend({
  hooks: {
    afterResponse: [
      async (request, options, response) => {
        const data = await response.json();
        const { ok, status } = response;
        if (ok) {
          return data;
        }
        const { message = "An error occurred while fetching the data." } = data;
        throw new ApiError({ status, message });
      }
    ]
  }
});
const api = baseFetcher.extend({
  prefixUrl: "https://mint.club/api",
  timeout: 6e4
  // 1 min timeout
});

const EMPTY_ROOT = "0x0000000000000000000000000000000000000000000000000000000000000000";
class Airdrop {
  chainId;
  constructor(chainId) {
    this.chainId = chainId;
  }
  getTotalAirdropCount() {
    return airdropContract.network(this.chainId).read({
      functionName: "distributionCount"
    });
  }
  async getAirdropById(airdropId) {
    const [
      token,
      isERC20,
      walletCount,
      claimCount,
      amountPerClaim,
      startTime,
      endTime,
      owner,
      refundedAt,
      merkleRoot,
      title,
      ipfsCID
    ] = await airdropContract.network(this.chainId).read({
      functionName: "distributions",
      args: [BigInt(airdropId)]
    });
    return {
      token,
      isERC20,
      walletCount,
      claimCount,
      amountPerClaim,
      startTime,
      endTime,
      owner,
      refundedAt,
      merkleRoot,
      title,
      ipfsCID
    };
  }
  getAmountClaimed(airdropId) {
    return airdropContract.network(this.chainId).read({
      functionName: "getAmountClaimed",
      args: [BigInt(airdropId)]
    });
  }
  getAmountLeft(airdropId) {
    return airdropContract.network(this.chainId).read({
      functionName: "getAmountLeft",
      args: [BigInt(airdropId)]
    });
  }
  getAirdropIdsByOwner(params) {
    const { owner, start = 0, end = 1e3 } = params;
    return airdropContract.network(this.chainId).read({
      functionName: "getDistributionIdsByOwner",
      args: [owner, BigInt(start), BigInt(end)]
    });
  }
  getAirdropIdsByToken(params) {
    const { token, start = 0, end = 1e3 } = params;
    return airdropContract.network(this.chainId).read({
      functionName: "getDistributionIdsByToken",
      args: [token, BigInt(start), BigInt(end)]
    });
  }
  getIsClaimed(airdropId, account) {
    return airdropContract.network(this.chainId).read({
      functionName: "isClaimed",
      args: [BigInt(airdropId), account]
    });
  }
  getIsWhitelistOnly(airdropId) {
    return airdropContract.network(this.chainId).read({
      functionName: "isWhitelistOnly",
      args: [BigInt(airdropId)]
    });
  }
  async getMerkleProof(airdropId) {
    const { ipfsCID } = await this.getAirdropById(airdropId);
    const merkleProof = await api.get(`ipfs/whitelist?cid=${ipfsCID}`).json().catch(() => {
      return baseFetcher.get(`https://cf-ipfs.com/ipfs/${ipfsCID}`).json();
    });
    return merkleProof;
  }
  async getIsWhitelisted(airdropId, account) {
    const { merkleRoot } = await this.getAirdropById(airdropId);
    if (merkleRoot === EMPTY_ROOT)
      return Promise.resolve(true);
    return airdropContract.network(this.chainId).read({
      functionName: "isWhitelisted",
      args: [BigInt(airdropId), account, await this.getMerkleProof(airdropId)]
    });
  }
  async claimAirdrop(params) {
    const { airdropId } = params;
    return airdropContract.network(this.chainId).write({
      ...params,
      functionName: "claim",
      args: [BigInt(airdropId), await this.getMerkleProof(airdropId)]
    });
  }
  createAirdrop(params) {
    const { token, isERC20, amountPerClaim, walletCount, startTime, endTime, merkleRoot, title, ipfsCID } = params;
    return airdropContract.network(this.chainId).write({
      ...params,
      functionName: "createDistribution",
      args: [token, isERC20, amountPerClaim, walletCount, startTime, endTime, merkleRoot, title, ipfsCID]
    });
  }
  cancelAirdrop(params) {
    const { airdropId } = params;
    return airdropContract.network(this.chainId).write({
      ...params,
      functionName: "refund",
      args: [BigInt(airdropId)]
    });
  }
}

class Ipfs {
  async add(apiKey, blob) {
    if (!apiKey)
      throw new FilebaseKeyNeededErrror();
    const client$1 = new client.FilebaseClient({ token: apiKey });
    const cid = await client$1.storeBlob(blob);
    return cid;
  }
  isIpfsUrl(url) {
    return url.toLowerCase().startsWith("ipfs://");
  }
  isHttpUrl(url) {
    return url.toLowerCase().startsWith("http://") || url.toLowerCase().startsWith("https://");
  }
  validateHttpUrl(url) {
    let urlObj;
    try {
      urlObj = new URL(url);
    } catch (e) {
      throw new InvalidImageProvidedError();
    }
    const valid = urlObj.protocol === "http:" || urlObj.protocol === "https:";
    if (!valid) {
      throw new InvalidImageProvidedError();
    }
    return valid;
  }
  hashToGatewayUrl(hash, gateway = "https://cf-ipfs.com/ipfs/") {
    if (hash.includes("ipfs://")) {
      hash = hash.replace("ipfs://", "");
    }
    return `${gateway}${hash}`;
  }
  gatewayUrlToHash(url) {
    return "ipfs://" + url.split("ipfs/").pop();
  }
  validateIpfsHash(ipfsUrl) {
    const hash = ipfsUrl.replace(/^ipfs:\/\//, "");
    const cidv0Pattern = /^Qm[1-9A-HJ-NP-Za-km-z]{44}$/;
    const cidv1Pattern = /^b[1-9A-Za-z]{49,}$/;
    const matched = cidv0Pattern.test(hash) || cidv1Pattern.test(hash);
    if (!matched) {
      throw new InvalidImageProvidedError();
    }
    return matched;
  }
  async upload(params) {
    const { filebaseApiKey, media } = params;
    const hash = await this.add(filebaseApiKey, media);
    return `ipfs://${hash}`;
  }
  async uploadMetadata(data) {
    const { filebaseApiKey, name, image, video, description, external_url, attributes } = data;
    const defaultExternalLink = `https://mint.club`;
    const defaultDescription = [
      `A Bonding Curved ERC-1155 token powered by mint.club bonding curve protocol.`,
      defaultExternalLink
    ].join("\n\n");
    const finalMetadata = {
      name,
      description: defaultDescription,
      image,
      external_url: defaultExternalLink,
      attributes: []
    };
    if (video) {
      finalMetadata.animation_url = video;
    }
    if (description)
      finalMetadata.description = description;
    if (external_url)
      finalMetadata.external_url = external_url;
    if (attributes)
      finalMetadata.attributes = attributes;
    const metadata = JSON.stringify(finalMetadata);
    const metadataBuffer = new Blob([metadata], { type: "application/json" });
    const jsonHash = await this.add(filebaseApiKey, metadataBuffer);
    return `ipfs://${jsonHash}`;
  }
}

const STABLE_COINS = {
  [chains.mainnet.id]: {
    address: "0xdac17f958d2ee523a2206206994597c13d831ec7",
    symbol: "USDT",
    decimals: 6n
  },
  // USDT
  [chains.optimism.id]: {
    address: "0x94b008aa00579c1307b0ef2c499ad98a8ce58e58",
    symbol: "USDT",
    decimals: 6n
  },
  // USDT
  [chains.arbitrum.id]: {
    address: "0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9",
    symbol: "USDT",
    decimals: 6n
  },
  // USDT
  [chains.avalanche.id]: {
    address: "0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7",
    symbol: "USDT",
    decimals: 6n
  },
  // USDT
  [chains.polygon.id]: {
    address: "0xc2132d05d31c914a87c6611c10748aeb04b58e8f",
    symbol: "USDT",
    decimals: 6n
  },
  // USDT
  [chains.bsc.id]: {
    address: "0x55d398326f99059ff775485246999027b3197955",
    symbol: "USDT",
    decimals: 18n
  },
  // USDT
  [chains.base.id]: {
    address: "0xd9aaec86b65d86f6a7b5b1b0c42ffa531710b6ca",
    symbol: "USDBC",
    decimals: 6n
  },
  // USDBC
  [chains.sepolia.id]: { address: "0x", symbol: "", decimals: 0n },
  [chains.blast.id]: { address: "0x", symbol: "", decimals: 0n },
  [chains.blastSepolia.id]: { address: "0x", symbol: "", decimals: 0n },
  [chains.avalancheFuji.id]: { address: "0x", symbol: "", decimals: 0n }
};
class OneInch {
  chainId;
  constructor(chainId) {
    this.chainId = chainId;
  }
  async getUsdRate({ tokenAddress, tokenDecimals }) {
    if (!viem.isAddress(STABLE_COINS[this.chainId].address) || STABLE_COINS[this.chainId].address === "0x") {
      return null;
    }
    const isSameToken = viem.isAddress(tokenAddress) && viem.getAddress(tokenAddress) === viem.getAddress(STABLE_COINS[this.chainId].address);
    if (isSameToken)
      return { rate: 1, stableCoin: STABLE_COINS[this.chainId] };
    const rate = await oneInchContract.network(this.chainId).read({
      functionName: "getRate",
      args: [tokenAddress, STABLE_COINS[this.chainId].address, false]
    });
    const stableCoinDecimals = STABLE_COINS[this.chainId].decimals;
    const rateToNumber = toNumber(rate, Number(18n + stableCoinDecimals) - tokenDecimals);
    return { rate: rateToNumber, stableCoin: STABLE_COINS[this.chainId] };
  }
}

function isFalse(value) {
  return typeof value === "undefined" || value === void 0 || value === null;
}

class Token {
  tokenAddress;
  clientHelper;
  airdropHelper;
  oneinch;
  ipfsHelper;
  symbol;
  tokenType;
  chain;
  chainId;
  constructor(params) {
    const { symbolOrAddress, chainId, tokenType } = params;
    if (viem.isAddress(symbolOrAddress)) {
      this.tokenAddress = symbolOrAddress;
    } else {
      this.tokenAddress = computeCreate2Address(chainId, tokenType, symbolOrAddress);
      this.symbol = symbolOrAddress;
    }
    this.chain = getChain(chainId);
    this.chainId = chainId;
    this.tokenType = tokenType;
    this.clientHelper = new Client();
    this.ipfsHelper = new Ipfs();
    this.oneinch = new OneInch(chainId);
    this.airdropHelper = new Airdrop(this.chainId);
  }
  async getConnectedWalletAddress() {
    const connectedAddress = await this.clientHelper.account();
    if (!connectedAddress)
      throw new WalletNotConnectedError();
    return connectedAddress;
  }
  async tokenToApprove(tradeType) {
    return tradeType === "buy" ? await this.getReserveTokenAddress() : this.getTokenAddress();
  }
  async bondContractApproved(params) {
    const { tradeType, walletAddress } = params;
    const tokenToApprove = await this.tokenToApprove(tradeType);
    if (this.tokenType === "ERC1155" && tradeType === "sell") {
      return erc1155Contract.network(this.chainId).read({
        tokenAddress: this.tokenAddress,
        functionName: "isApprovedForAll",
        args: [walletAddress, getMintClubContractAddress("BOND", this.chainId)]
      });
    }
    let amountToSpend = viem.maxUint256;
    if ("amountToSpend" in params && params?.amountToSpend !== void 0) {
      amountToSpend = params.amountToSpend;
    }
    const allowance = await erc20Contract.network(this.chainId).read({
      tokenAddress: tokenToApprove,
      functionName: "allowance",
      args: [walletAddress, getMintClubContractAddress("BOND", this.chainId)]
    });
    return allowance >= amountToSpend;
  }
  async contractIsApproved(params, contract) {
    const connectedAddress = await this.getConnectedWalletAddress();
    if (this.tokenType === "ERC1155") {
      return erc1155Contract.network(this.chainId).read({
        ...params,
        tokenAddress: this.tokenAddress,
        functionName: "isApprovedForAll",
        args: [connectedAddress, getMintClubContractAddress(contract, this.chainId)]
      });
    } else {
      let amountToSpend = viem.maxUint256;
      if ("allowanceAmount" in params && params?.allowanceAmount !== void 0) {
        amountToSpend = params.allowanceAmount;
      }
      const allowance = await erc20Contract.network(this.chainId).read({
        ...params,
        tokenAddress: this.tokenAddress,
        functionName: "allowance",
        args: [connectedAddress, getMintClubContractAddress(contract, this.chainId)]
      });
      return allowance >= amountToSpend;
    }
  }
  approveContract(params, contract) {
    if (this.tokenType === "ERC1155") {
      return erc1155Contract.network(this.chainId).write({
        ...params,
        tokenAddress: this.tokenAddress,
        functionName: "setApprovalForAll",
        args: [getMintClubContractAddress(contract, this.chainId), true]
      });
    } else {
      let amountToSpend = viem.maxUint256;
      if ("allowanceAmount" in params && params?.allowanceAmount !== void 0) {
        amountToSpend = params.allowanceAmount;
      }
      return erc20Contract.network(this.chainId).write({
        ...params,
        tokenAddress: this.tokenAddress,
        functionName: "approve",
        args: [getMintClubContractAddress(contract, this.chainId), amountToSpend]
      });
    }
  }
  async approveBond(params) {
    const { tradeType, onAllowanceSignatureRequest, onAllowanceSigned, onAllowanceSuccess } = params;
    const tokenToCheck = await this.tokenToApprove(tradeType);
    if (this.tokenType === "ERC1155" && tradeType === "sell") {
      return erc1155Contract.network(this.chainId).write({
        ...params,
        onSignatureRequest: onAllowanceSignatureRequest,
        onSigned: onAllowanceSigned,
        onSuccess: onAllowanceSuccess,
        tokenAddress: this.tokenAddress,
        functionName: "setApprovalForAll",
        args: [getMintClubContractAddress("BOND", this.chainId), true]
      });
    } else {
      let amountToSpend = viem.maxUint256;
      if ("allowanceAmount" in params && params?.allowanceAmount !== void 0) {
        amountToSpend = params.allowanceAmount;
      }
      return erc20Contract.network(this.chainId).write({
        ...params,
        onSignatureRequest: onAllowanceSignatureRequest,
        onSigned: onAllowanceSigned,
        onSuccess: onAllowanceSuccess,
        tokenAddress: tokenToCheck,
        functionName: "approve",
        args: [getMintClubContractAddress("BOND", this.chainId), amountToSpend]
      });
    }
  }
  getCreationFee() {
    return bondContract.network(this.chainId).read({
      functionName: "creationFee"
    });
  }
  async zapAvailable() {
    const { reserveToken } = await this.getTokenBond();
    const reserveIsWrapped = WRAPPED_NATIVE_TOKENS[this.chainId].tokenAddress === reserveToken;
    return reserveIsWrapped;
  }
  exists() {
    return bondContract.network(this.chainId).read({
      functionName: "exists",
      args: [this.tokenAddress]
    });
  }
  async getReserveToken() {
    const { reserveToken } = await this.getTokenBond();
    const [name, symbol, decimals] = await Promise.all([
      erc20Contract.network(this.chainId).read({ tokenAddress: reserveToken, functionName: "name" }),
      erc20Contract.network(this.chainId).read({ tokenAddress: reserveToken, functionName: "symbol" }),
      erc20Contract.network(this.chainId).read({ tokenAddress: reserveToken, functionName: "decimals" })
    ]);
    return {
      address: reserveToken,
      name,
      symbol,
      decimals
    };
  }
  async getReserveTokenAddress() {
    const { reserveToken } = await this.getTokenBond();
    return reserveToken;
  }
  getTokenAddress() {
    return this.tokenAddress;
  }
  async getUsdRate(amount = 1) {
    const rateData = await this.oneinch.getUsdRate({
      tokenAddress: this.tokenAddress,
      tokenDecimals: this.tokenType === "ERC20" ? 18 : 0
    });
    if (isFalse(rateData))
      return { usdRate: null, stableCoin: null };
    const { rate, stableCoin } = rateData;
    return { usdRate: rate * amount, stableCoin };
  }
  getDetail() {
    return bondContract.network(this.chainId).read({
      functionName: "getDetail",
      args: [this.tokenAddress]
    });
  }
  async getTokenBond() {
    const [creator, mintRoyalty, burnRoyalty, createdAt, reserveToken, reserveBalance] = await bondContract.network(this.chainId).read({
      functionName: "tokenBond",
      args: [this.tokenAddress]
    });
    return {
      creator,
      mintRoyalty,
      burnRoyalty,
      createdAt,
      reserveToken,
      reserveBalance
    };
  }
  getSteps() {
    return bondContract.network(this.chainId).read({
      functionName: "getSteps",
      args: [this.tokenAddress]
    });
  }
  getMaxSupply() {
    return bondContract.network(this.chainId).read({
      functionName: "maxSupply",
      args: [this.tokenAddress]
    });
  }
  getPriceForNextMint() {
    return bondContract.network(this.chainId).read({
      functionName: "priceForNextMint",
      args: [this.tokenAddress]
    });
  }
  getSellEstimation(amount) {
    return bondContract.network(this.chainId).read({
      functionName: "getRefundForTokens",
      args: [this.tokenAddress, amount]
    });
  }
  getBuyEstimation(amount) {
    return bondContract.network(this.chainId).read({
      functionName: "getReserveForToken",
      args: [this.tokenAddress, amount]
    });
  }
  async checkAndPrepareCreateArgs(params) {
    if (!this.symbol) {
      throw new SymbolNotDefinedError();
    }
    const exists = await this.exists();
    if (exists) {
      throw new TokenAlreadyExistsError();
    }
    const args = generateCreateArgs({ ...params, tokenType: this.tokenType, symbol: this.symbol });
    const fee = await this.getCreationFee();
    return { args, fee };
  }
  async buy(params) {
    const { amount, slippage = 0, recipient, onError } = params;
    try {
      const connectedAddress = await this.getConnectedWalletAddress();
      const [estimatedOutcome, royalty] = await this.getBuyEstimation(amount);
      const maxReserveAmount = estimatedOutcome + estimatedOutcome * BigInt(slippage * 100) / 10000n + royalty;
      const bondApproved = await this.bondContractApproved({
        walletAddress: connectedAddress,
        amountToSpend: maxReserveAmount,
        tradeType: "buy"
      });
      if (!bondApproved) {
        return this.approveBond({
          ...params,
          tradeType: "buy",
          amountToSpend: maxReserveAmount
        });
      }
      return bondContract.network(this.chainId).write({
        ...params,
        functionName: "mint",
        args: [this.tokenAddress, amount, maxReserveAmount, recipient || connectedAddress]
      });
    } catch (e) {
      onError?.(e);
    }
  }
  async sell(params) {
    const { amount, slippage = 0, recipient, onError } = params;
    try {
      const connectedAddress = await this.getConnectedWalletAddress();
      const [estimatedOutcome, royalty] = await this.getSellEstimation(amount);
      const maxReserveAmount = estimatedOutcome - estimatedOutcome * BigInt(slippage * 100) / 10000n - royalty;
      const bondApproved = await this.bondContractApproved({
        walletAddress: connectedAddress,
        amountToSpend: amount,
        tradeType: "sell"
      });
      if (!bondApproved) {
        return this.approveBond({
          ...params,
          tradeType: "sell",
          amountToSpend: amount
        });
      }
      return bondContract.network(this.chainId).write({
        ...params,
        functionName: "burn",
        args: [this.tokenAddress, amount, maxReserveAmount, recipient || connectedAddress]
      });
    } catch (e) {
      onError?.(e);
    }
  }
  async transfer(params) {
    const { amount, recipient, onError } = params;
    try {
      if (this.tokenType === "ERC20") {
        return erc20Contract.network(this.chainId).write({
          ...params,
          tokenAddress: this.getTokenAddress(),
          functionName: "transfer",
          args: [recipient, amount]
        });
      } else {
        const connectedAddress = await this.getConnectedWalletAddress();
        return erc1155Contract.network(this.chainId).write({
          ...params,
          tokenAddress: this.getTokenAddress(),
          functionName: "safeTransferFrom",
          args: [connectedAddress, recipient, 0n, amount, "0x"]
        });
      }
    } catch (e) {
      onError?.(e);
    }
  }
  async createAirdrop(params) {
    const { title, filebaseApiKey, wallets, amountPerClaim: _amountPerClaim, startTime, endTime } = params;
    if (wallets.some((address) => !viem.isAddress(address))) {
      throw new AirdropContainsInvalidWalletError();
    }
    const isERC20 = this.tokenType === "ERC20";
    const walletCount = wallets.length;
    let decimals = 0;
    if (this.tokenType === "ERC20") {
      decimals = await erc20Contract.network(this.chainId).read({
        tokenAddress: this.getTokenAddress(),
        functionName: "decimals"
      });
    }
    const amountPerClaim = wei(_amountPerClaim, decimals);
    const totalAmount = BigInt(amountPerClaim) * BigInt(walletCount);
    const approved = await this.contractIsApproved(
      {
        allowanceAmount: totalAmount,
        amountToSpend: totalAmount
      },
      "MERKLE"
    );
    if (!approved) {
      return this.approveContract(
        {
          ...params,
          allowanceAmount: totalAmount,
          amountToSpend: totalAmount
        },
        "MERKLE"
      );
    }
    const leaves = wallets.map((address) => viem.keccak256(address));
    const tree = new MerkleTree(leaves, viem.keccak256, {
      sortPairs: true
    });
    const merkleRoot = `0x${tree.getRoot().toString("hex")}`;
    const json = JSON.stringify(wallets, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const ipfsCID = await this.ipfsHelper.add(filebaseApiKey, blob);
    return this.airdropHelper.createAirdrop({
      token: this.tokenAddress,
      isERC20,
      amountPerClaim,
      walletCount,
      startTime: startTime ? Math.floor(startTime.getTime() / 1e3) : 0,
      endTime: Math.floor(endTime.getTime() / 1e3),
      merkleRoot,
      title,
      ipfsCID
    });
  }
}

class ERC1155 extends Token {
  constructor(params) {
    super({
      ...params,
      tokenType: "ERC1155"
    });
  }
  getBalanceOf(walletAddress) {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "balanceOf",
      args: [walletAddress, 0n]
    });
  }
  getBalanceOfBatch(walletAddresses) {
    const ids = Array(walletAddresses.length).fill(0n);
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "balanceOfBatch",
      args: [walletAddresses, ids]
    });
  }
  getBondAddress() {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "bond"
    });
  }
  getContractURI() {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "contractURI"
    });
  }
  getDecimals() {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "decimals"
    });
  }
  getIsApprovedForAll(params) {
    const { owner, spender } = params;
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "isApprovedForAll",
      args: [owner, spender]
    });
  }
  getName() {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "name"
    });
  }
  getSupportsInterface(interfaceId) {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "supportsInterface",
      args: [interfaceId]
    });
  }
  getSymbol() {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "symbol"
    });
  }
  getTotalSupply() {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "totalSupply"
    });
  }
  getMetadataUri() {
    return erc1155Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "uri",
      args: [0n]
    });
  }
  async getImageUri() {
    const jsonHash = await this.getMetadataUri();
    const metadataIpfsUrl = this.ipfsHelper.hashToGatewayUrl(jsonHash);
    const { image } = await fetch(metadataIpfsUrl).then((res) => res.json());
    return image;
  }
  async create(params) {
    const { onError, metadataUrl } = params;
    try {
      const { args, fee } = await this.checkAndPrepareCreateArgs(params);
      if (metadataUrl.startsWith("ipfs://")) {
        this.ipfsHelper.validateIpfsHash(metadataUrl);
      }
      return bondContract.network(this.chainId).write({
        ...params,
        functionName: "createMultiToken",
        args: [Object.assign(args.tokenParams, { uri: metadataUrl }), args.bondParams],
        value: fee
      });
    } catch (e) {
      console.error(e);
      onError?.(e);
    }
  }
  async approve(params) {
    const { spender, approved } = params;
    return erc1155Contract.network(this.chainId).write({
      ...params,
      tokenAddress: this.getTokenAddress(),
      functionName: "setApprovalForAll",
      args: [spender, approved]
    });
  }
}

class ERC20 extends Token {
  constructor(params) {
    super({
      ...params,
      tokenType: "ERC20"
    });
  }
  getAllowance(params) {
    const { owner, spender } = params;
    return erc20Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "allowance",
      args: [owner, spender]
    });
  }
  getBalanceOf(walletAddress) {
    return erc20Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "balanceOf",
      args: [walletAddress]
    });
  }
  getBondAddress() {
    return erc20Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "bond"
    });
  }
  getDecimals() {
    return erc20Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "decimals"
    });
  }
  getName() {
    return erc20Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "name"
    });
  }
  getSymbol() {
    return erc20Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "symbol"
    });
  }
  getTotalSupply() {
    return erc20Contract.network(this.chainId).read({
      tokenAddress: this.getTokenAddress(),
      functionName: "totalSupply"
    });
  }
  async approve(params) {
    const { spender, amount } = params;
    return erc20Contract.network(this.chainId).write({
      ...params,
      tokenAddress: this.getTokenAddress(),
      functionName: "approve",
      args: [spender, amount]
    });
  }
  async create(params) {
    try {
      const { args, fee } = await this.checkAndPrepareCreateArgs(params);
      return bondContract.network(this.chainId).write({
        ...params,
        functionName: "createToken",
        args: [args.tokenParams, args.bondParams],
        value: fee
      });
    } catch (e) {
      params.onError?.(e);
    }
  }
}

class Lockup {
  chainId;
  constructor(chainId) {
    this.chainId = chainId;
  }
  getTotalLockUpCount() {
    return lockupContract.network(this.chainId).read({
      functionName: "lockUpCount"
    });
  }
  getLockUpIdsByReceiver(params) {
    const { receiver, start = 0, end = 1e3 } = params;
    return lockupContract.network(this.chainId).read({
      functionName: "getLockUpIdsByReceiver",
      args: [receiver, BigInt(start), BigInt(end)]
    });
  }
  getLockUpIdsByToken(params) {
    const { token, start = 0, end = 1e3 } = params;
    return lockupContract.network(this.chainId).read({
      functionName: "getLockUpIdsByToken",
      args: [token, BigInt(start), BigInt(end)]
    });
  }
  async getLockUpById(lockUpId) {
    const [token, isERC20, unlockTime, unlocked, amount, receiver, title] = await lockupContract.network(this.chainId).read({
      functionName: "lockUps",
      args: [BigInt(lockUpId)]
    });
    return {
      token,
      isERC20,
      unlockTime,
      unlocked,
      amount,
      receiver,
      title
    };
  }
  createLockUp(params) {
    const { token, isERC20, amount, unlockTime, receiver, title } = params;
    return lockupContract.network(this.chainId).write({
      ...params,
      functionName: "createLockUp",
      args: [token, isERC20, amount, unlockTime, receiver, title]
    });
  }
  unlock(params) {
    const { lockUpId } = params;
    return lockupContract.network(this.chainId).write({
      ...params,
      functionName: "unlock",
      args: [BigInt(lockUpId)]
    });
  }
}

class Utils {
  generateMerkleRoot(wallets) {
    const leaves = wallets.map((address) => viem.keccak256(address));
    const tree = new MerkleTree(leaves, viem.keccak256, {
      sortPairs: true
    });
    const merkleRoot = `0x${tree.getRoot().toString("hex")}`;
    return merkleRoot;
  }
}

class MintClubSDK {
  // chain agnostic
  wallet = new Client();
  ipfs = new Ipfs();
  utils = new Utils();
  network(id) {
    let chainId;
    if (typeof id === "string") {
      chainId = chainStringToId(id);
    } else {
      chainId = id;
    }
    const clientHelper = new Client();
    return this.withClientHelper(clientHelper, chainId);
  }
  withClientHelper(clientHelper, chainId) {
    return Object.assign(clientHelper, {
      getPublicClient() {
        return clientHelper._getPublicClient(chainId);
      },
      token: (symbolOrAddress) => {
        return new ERC20({
          symbolOrAddress,
          chainId
        });
      },
      nft: (symbolOrAddress) => {
        return new ERC1155({
          symbolOrAddress,
          chainId
        });
      },
      airdrop: new Airdrop(chainId),
      lockup: new Lockup(chainId),
      bond: new Bond(chainId)
    });
  }
  withPublicClient(publicClient) {
    const chainId = publicClient.chain?.id;
    if (chainId === void 0)
      throw new InvalidClientError();
    const clientHelper = new Client().withPublicClient(publicClient);
    return this.withClientHelper(clientHelper, chainId);
  }
  withWalletClient(walletClient) {
    const chainId = walletClient.chain?.id;
    if (chainId === void 0)
      throw new InvalidClientError();
    if (walletClient.chain?.id === void 0)
      throw new InvalidClientError();
    const clientHelper = new Client().withWalletClient(walletClient);
    return this.withClientHelper(clientHelper, chainId);
  }
}

function calculateRoyalty(amount, rate) {
  return amount * BigInt(rate) / 10000n;
}
function getCurrentStepIndex(currentSupply, bondSteps) {
  return bondSteps.findIndex((step) => currentSupply < step.rangeTo) || bondSteps.length - 1;
}
function calculateAdjustments(tokens, bondSteps, currentSupply, multiFactor, royaltyRate, slippage, isMinting) {
  let totalAmount = 0n;
  let tokensProcessed = tokens;
  let stepIndex = getCurrentStepIndex(currentSupply, bondSteps);
  let tempCurrentSupply = currentSupply;
  while (tokensProcessed > 0n && stepIndex < bondSteps.length && stepIndex >= 0) {
    const step = bondSteps[stepIndex];
    const supplyDelta = isMinting ? step.rangeTo - tempCurrentSupply : tempCurrentSupply - (stepIndex > 0 ? bondSteps[stepIndex - 1].rangeTo : 0n);
    const tokensToProcess = tokensProcessed > supplyDelta ? supplyDelta : tokensProcessed;
    const factor = isMinting ? multiFactor - 1n : 0n;
    totalAmount += (tokensToProcess * step.price + factor) / multiFactor;
    tokensProcessed -= tokensToProcess;
    tempCurrentSupply += isMinting ? tokensToProcess : -tokensToProcess;
    stepIndex += isMinting ? 1 : -1;
  }
  const royalty = calculateRoyalty(totalAmount, royaltyRate);
  let adjustedAmount = totalAmount + (isMinting ? royalty : -royalty);
  const slippageAmount = calculateRoyalty(adjustedAmount, slippage);
  adjustedAmount += isMinting ? slippageAmount : -slippageAmount;
  return { adjustedAmount, royalty };
}
function binarySearch(params) {
  const { reserveAmount, bondSteps, currentSupply, maxSupply, multiFactor, royaltyRate, slippage, isMinting } = params;
  let low = 0n;
  let high = isMinting ? maxSupply - currentSupply : currentSupply;
  let mid = 0n;
  let lastClosest = 0n;
  const MAX_ITERATIONS = 1e3;
  let iterations = 0;
  while (low <= high && iterations++ < MAX_ITERATIONS) {
    mid = (high + low) / 2n;
    const { adjustedAmount } = calculateAdjustments(
      mid,
      bondSteps,
      currentSupply,
      multiFactor,
      royaltyRate,
      slippage,
      isMinting
    );
    if (adjustedAmount === reserveAmount)
      return mid;
    else if (adjustedAmount < reserveAmount) {
      low = mid + 1n;
      lastClosest = mid;
    } else
      high = mid - 1n;
  }
  return lastClosest;
}
function binaryReverseMint(params) {
  return binarySearch({
    ...params,
    royaltyRate: params.mintRoyalty,
    isMinting: true
  });
}
function binaryReverseBurn(params) {
  return binarySearch({
    ...params,
    maxSupply: params.currentSupply,
    royaltyRate: params.burnRoyalty,
    isMinting: false
  });
}

const abis = {
  BOND: BOND_ABI,
  ERC20: ERC20_ABI,
  ERC1155: ERC1155_ABI,
  LOCKER: LOCKER_ABI,
  MERKLE: MERKLE_ABI,
  ONEINCH: ONEINCH_ABI,
  ZAP: ZAP_ABI
};
const whitelistedTokens = TOKENS;
const errorMessages = CONTRACT_ERROR_MESSAGES;
const supportedChains = [
  "ethereum",
  "sepolia",
  "bnbchain",
  "polygon",
  "arbitrum",
  "optimism",
  "avalanche",
  "base"
];
const supportedChainsMap = {
  ethereum: chains.mainnet.id,
  sepolia: chains.sepolia.id,
  bnbchain: chains.bsc.id,
  polygon: chains.polygon.id,
  arbitrum: chains.arbitrum.id,
  optimism: chains.optimism.id,
  avalanche: chains.avalanche.id,
  base: chains.base.id,
  blast: chains.blast.id,
  blastsepolia: chains.blastSepolia.id,
  avalanchefuji: chains.avalancheFuji.id
};
const mintclub = new MintClubSDK();

exports.BOND_ABI = BOND_ABI;
exports.BOND_ERROR_MESSAGES = BOND_ERROR_MESSAGES;
exports.CHAINS = CHAINS;
exports.CHAIN_MAP = CHAIN_MAP;
exports.CHAIN_NAME_ID_MAP = CHAIN_NAME_ID_MAP;
exports.COINGECKO_NETWORK_IDS = COINGECKO_NETWORK_IDS;
exports.CONTRACT_ERROR_MESSAGES = CONTRACT_ERROR_MESSAGES;
exports.CurveEnum = CurveEnum;
exports.DEFAULT_RANK_OPTIONS = DEFAULT_RANK_OPTIONS;
exports.ERC1155_ABI = ERC1155_ABI;
exports.ERC1155_ERROR_MESSAGES = ERC1155_ERROR_MESSAGES;
exports.ERC20_ABI = ERC20_ABI;
exports.ERC20_ERROR_MESSAGES = ERC20_ERROR_MESSAGES;
exports.LOCKER_ABI = LOCKER_ABI;
exports.LOCKER_ERROR_MESSAGES = LOCKER_ERROR_MESSAGES;
exports.MERKLE_ABI = MERKLE_ABI;
exports.MERKLE_ERROR_MESSAGES = MERKLE_ERROR_MESSAGES;
exports.ONEINCH_ABI = ONEINCH_ABI;
exports.RPCS = RPCS;
exports.TOKENS = TOKENS;
exports.WRAPPED_NATIVE_TOKENS = WRAPPED_NATIVE_TOKENS;
exports.ZAP_ABI = ZAP_ABI;
exports.ZAP_ERROR_MESSAGES = ZAP_ERROR_MESSAGES;
exports.abis = abis;
exports.airdropContract = airdropContract;
exports.applyDecimals = applyDecimals;
exports.binaryReverseBurn = binaryReverseBurn;
exports.binaryReverseMint = binaryReverseMint;
exports.bondContract = bondContract;
exports.calculateArea = calculateArea;
exports.calculateRoyalty = calculateRoyalty;
exports.chainIdToString = chainIdToString;
exports.chainRPCFallbacks = chainRPCFallbacks;
exports.chainStringToId = chainStringToId;
exports.commify = commify;
exports.computeCreate2Address = computeCreate2Address;
exports.countDecimals = countDecimals;
exports.countLeadingZeros = countLeadingZeros;
exports.createRandomAddress = createRandomAddress;
exports.erc1155Contract = erc1155Contract;
exports.erc20Contract = erc20Contract;
exports.errorMessages = errorMessages;
exports.formatGraphPoint = formatGraphPoint;
exports.generateCreateArgs = generateCreateArgs;
exports.generateSteps = generateSteps;
exports.generateTableData = generateTableData;
exports.getChain = getChain;
exports.getMintClubContractAddress = getMintClubContractAddress;
exports.getValueAfterLeadingZeros = getValueAfterLeadingZeros;
exports.graphTypes = graphTypes;
exports.handleScientificNotation = handleScientificNotation;
exports.lockupContract = lockupContract;
exports.mintclub = mintclub;
exports.oneInchContract = oneInchContract;
exports.precisionRound = precisionRound;
exports.shortenNumber = shortenNumber;
exports.supportedChains = supportedChains;
exports.supportedChainsMap = supportedChainsMap;
exports.toFixed = toFixed;
exports.toNumber = toNumber;
exports.uncommify = uncommify;
exports.wei = wei$1;
exports.whitelistedTokens = whitelistedTokens;
exports.zapContract = zapContract;
